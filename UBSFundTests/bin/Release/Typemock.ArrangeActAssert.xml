<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Typemock.ArrangeActAssert</name>
    </assembly>
    <members>
        <member name="M:TypeMock.ArrangeActAssert.FakeLog.FakeLogDataExtensions.GetSignature(System.Reflection.MethodBase)">
            <summary>
            Return the method signature as a string.
            </summary>
            <param name="method">The Method</param>
            <returns>Method signature</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.FakeLog.FakeLogDataExtensions.TypeName(System.Type)">
            <summary>
            Get full type name with full namespace names
            </summary>
            <param name="type">Type. May be generic or nullable</param>
            <returns>Full type name, fully qualified namespaces</returns>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IBox`1">
            <summary>
            An interface that exposes the boxed value of ref or out parameters.
            </summary>
            <remarks>
            When invoking a non-public method that need ref or out arguments, use the Args class methods to create 
            boxed values you can later check for their values.</remarks>
            <typeparam name="T">The type of the boxed value</typeparam>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Fluent.IBox`1.Value">
            <summary>
            Retrieve the value returned from boxed out or ref arguments
            </summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IInvoker">
            <summary>
            Interface for invoking events, private methods and static constructors
            </summary>
            <remarks>
            This interface is returned by the <see cref="P:TypeMock.ArrangeActAssert.Isolate.Invoke"/> property.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Event(System.Action,System.Object[])">
            <summary>
            Fires an event.
            </summary>
            <param name="eventAdderLambda">Accepts a method in the form of a Lambda expression containing a call to the 
            adder of the event being fired. Example: () => logger.LogEntryCreated += null.
            </param>
            <param name="parameters">The parameters to fire the event with.</param>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown when the number of arguments does not match the number of arguments the events expects.
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown when the arguments does not match the parameters types the event expects.
            </exception>
            <example>
            The following test fires an event and sets specific value as event parameter.
            <code>
            [TestMethod]
            [Isolated]
            public void FireEvent_ParameterEqualsRequestedValue()
            {
                int? actualEntryID = null;
            
                var logger = new RealLogger();
                logger.LogEntryCreated += (int entryId) => actualEntryID = entryId;
            
                var expectedLogEntryID = 100;
                Isolate.Invoke.Event(() => logger.LogEntryCreated += null, expectedLogEntryID);
            
                Assert.AreEqual(expectedLogEntryID, actualEntryID);
            }
            </code>
            The following test fires event while faking <see cref="T:System.EventHandler">EventHandler</see> default behavior using <see cref="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Event(System.Action,System.Object[])">EventWithExplicitArguments</see>.
            <code>
            [TestMethod]
            [Isolated]
            public void FireEvent_EventHandlerParametersEqualToRequetedValues()
            {
                object actualSender = null;
                EventArgs actualEventArgs = null;
            
                var logger = new RealLogger();
                logger.Initialized += (sender, args) =>
                                          {
                                              actualSender = sender;
                                              actualEventArgs = args;
                                          };
            
                var expectedEventArgs = new EventArgs();
                Isolate.Invoke.Event(() => logger.Initialized += null, logger, expectedEventArgs);
            
                Assert.AreSame(logger, actualSender);
                Assert.AreSame(expectedEventArgs, actualEventArgs);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Method(System.Object,System.String,System.Object[])">
            <summary>
            Invokes a method represented by the current instance, using the specified parameters
            </summary>
            <param name="targetObject">The object on which to invoke the method.</param>
            <param name="methodName">The name of the method</param>
            <param name="parameters">
            An argument list for the invoked method. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference</param>
            <example>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateMethod_ReturnCorrectValue()
            {
                // We will test ProductHandler.InternalCalculateWorth private method 
                var handler = new ProductHandler();
                var product = new Product("product", 10);
            
                // Invoke the event using three arguments and store the result 
                var result = Isolate.Invoke.Method(handler, "InternalCalculateWorth", product, 2, 5);
            
                Assert.AreEqual(15.3, result);
            }
            </example>
            <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Method(System.Type,System.String,System.Object[])">
            <summary>
            Invokes a static method represented by the current type, using the specified parameters
            </summary>
            <param name="targetType">The Type on which to invoke the method.</param>
            <param name="methodName">The name of the method</param>
            <param name="parameters">
            An argument list for the invoked method. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference
            </param>
            <example>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateStaticMethod_NewProductAddedToTheFactory()
            {
                // This test invokes the private static method ProductFactory.CreateProduct
                // and checks that the a new product with the same name was created
                ProductFactory.Reset();
                const string productName = "productName";
            
                // Invoke the method using productName as argument
                Isolate.Invoke.Method(typeof(ProductFactory), "CreateProduct", productName);
            
                Assert.IsTrue(ProductFactory.HasProduct(productName));
            }
            </example>
            <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Method``1(System.String,System.Object[])">
            <summary>
            Invokes a static method represented by the current type, using the specified parameters
            </summary>
            <typeparam name="T">The Type on which to invoke the method.</typeparam>
            <param name="methodName">The name of the method</param>
            <param name="parameters">
            An argument list for the invoked method. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference
            </param>
            <example>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateStaticMethod_NewProductAddedToTheFactory()
            {
                // This test invokes the private static method ProductFactory.CreateProduct
                // and checks that the a new product with the same name was created
                ProductFactory.Reset();
                const string productName = "productName";
            
                // Invoke the method using productName as argument
                Isolate.Invoke.Method&lt;ProductFactory&gt;("CreateProduct", productName);
            
                Assert.IsTrue(ProductFactory.HasProduct(productName));
            }
            </example>
            <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Null``1">
            <summary>
            Create a null argument in order to send to a private overloaded method
            </summary>
            <typeparam name="T">The type of the requested argument</typeparam>
            <example>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateStaticMethodWithOutArgument_OutArgumentIsUpdated()
            {
                // This test invokes the private static method with null argument,
                // this method has an overload with the same number of parameters        
            
                var result = (int) Isolate.Invoke.Method&lt;SomeClass&gt;("PrivateStaticOverloadedMethod", Isolate.Invoke.Null&lt;SomeObject&gt;());
                Assert.IsTrue(result != 0);
            }
            </example>
            <returns> A boxed null object to send to the private method.</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.MethodFromBase``1(System.Object,System.String,System.Object[])">
             <summary>
             Invokes a method represented by the current instance and requested type, using the specified parameters
             </summary>
             <param name="T">The type on which to invoke the method.</param>
             <param name="targetObject">The object on which to invoke the method.</param>
             <param name="methodName">The name of the method</param>
             <param name="parameters">
             An argument list for the invoked method. 
             This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
             If there are no parameters, parameters should be a null reference</param>
             <example>
             
             public class BaseClass
             {
                 protected int Foo()
                 {
                     // Does whatever
                     return 1;
                 }
             }
            
             public class DerivedClass : BaseClass
             {
                 protected new int Foo()
                 {
                     // Does something different from base
                     return 2;
                 }
             }
             
             [TestMethod]
             [Isolated]
             public void InvokeMethod_InvokePrivateMethodOfBase_ReturnCorrectValue()
             {
                 var handler = new DerivedClass();
             
                 // Invoke the protected virtual method of base through the derived instance 
                 var result = Isolate.Invoke.MethodFromBase&lt;BaseClass&gt;(handler, "Foo");
             
                 Assert.AreEqual(1, result);
             }
             </example>
             <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.MethodFromBase(System.Object,System.String,System.Object[])">
             <summary>
             Invokes a method on the base of the passed instance, using the specified parameters
             </summary>
             <param name="targetObject">The object on which to invoke the base method.</param>
             <param name="methodName">The name of the method</param>
             <param name="parameters">
             An argument list for the invoked method. 
             This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
             If there are no parameters, parameters should be a null reference</param>
             <example>
             
             public class BaseClass
             {
                 protected int Foo()
                 {
                     // Does whatever
                     return 1;
                 }
             }
            
             public class DerivedClass : BaseClass
             {
                 protected new int Foo()
                 {
                     // Does something different from base
                     return 2;
                 }
             }
             
             [TestMethod]
             [Isolated]
             public void InvokeMethod_InvokePrivateMethodOfBase_ReturnCorrectValue()
             {
                 var handler = new DerivedClass();
             
                 // Invoke the protected virtual method of base through the derived instance 
                 var result = Isolate.Invoke.MethodFromBase(handler, "Foo");
             
                 Assert.AreEqual(1, result);
             }
             </example>
             <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher">
            <summary>
            Returned by WasCalledWithArguments(), this interface contains methods for verifying arguments used in method calls.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">
            <summary>
            Verifies the argument values passed to <see cref="!:IVerifyHandler.WasCalledWithArguments"/> against a user provided delegate
            </summary>        
            <param name="argumentCheckingDelegate">
            A user provided delegate that is used to verify the actual values passed to the call.
            This delegate receives an object array with the actual argument values, and returns true 
            if the argument check passes.
            </param>
            <example>
            The following example verifies a method was called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1);
            
                Isolate.Verify.WasCalledWithArguments(() => fake.Log(0)).Matching(args => (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1, "str");
            
                Isolate.Verify.WasCalledWithArguments(() => fake.Log(0, null))
                    .Matching(args => ((int) args[0] > 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)">
            <summary>
            Specify the fake instance that will replace the created instance.
            </summary>
            <param name="fake">the fake instance that will replace the created instance</param>
            <returns>the fake</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.WithRecursiveFake">
            <summary>
            Replace the created instance with a recursive fake.
            </summary>
            <returns>the recursive fake</returns>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.ConstructorWillThrow(System.Exception)">
            <summary>
            Specify that an exception will be thrown the next time a construction is encountered for the type
            </summary>
            <param name="ex">The exception that will be thrown when the constructor is called</param>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.ICollectionReturnHandler">
            <summary>
            Interface for tweaking behavior for methods returning collection types. This can be used to replace collection values returned
            by a method or property with another test data collection.
            This interface is returned by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/> method.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.ICollectionReturnHandler.WillReturnCollectionValuesOf(System.Collections.IEnumerable)">
            <summary>
            Swaps a collection returned by a method or property with a collection of test data. Follows a call to 
            <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/>.
            </summary>
            <param name="collection">The collection to use instead of the replaced collection</param>
            <remarks>
            <para>
            This method is used as a completing statement to <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/>, and is used to
            replace the collection in the preceeding statement with the provided collection.
            This is useful when the code under test uses collection data that is prepared externally and then iterated over.
            The collection containing this data can be swapped with a test data collection prepared during the test set up and thus remove
            the dependency on the code populating the collection.
            </para>
            <para>
            <c>Note</c>: because Typemock Isolator does not currently support faking objects implemented in MsCorLib.dll, 
            the source collection used with <c>WhenCalled()</c> cannot be one implemented in MsCorLib, such as 
            <see cref="T:System.Collections.Generic.List`1"/> and <see cref="T:System.Collections.ArrayList"/>.
            </para>
            </remarks>
            <exception cref="T:TypeMock.TypeMockException">
            If the lambda expression provided in <c>Isolate.WhenCalled()</c> does not
            evaluate to an object implementing <see cref="T:System.Collections.IEnumerable"/>.
            </exception>
            <example>
            This example shows how to use Isolate.<see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/>.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ICollectionReturnHandler.WillReturnCollectionValuesOf(System.Collections.IEnumerable)"/> in order to 
            swap a collection data for test data:
            <code>
            [TestMethod]
            [Isolated]
            public void SwapCollectionValues_ReplaceCollectionWithTestData()
            {
                // Create a logger to use as test data
                RealLogger logger = new RealLogger();
                // Swap the logger collection for the class under test with a collection containing the prepared test data
                Isolate.WhenCalled(() => LoggerFactory.Loggers).WillReturnCollectionValuesOf(new[] { logger });
            
                // Verify the GetLogger() method returned the existing logger instead of creating a new one.
                RealLogger actual = LoggerFactory.GetLogger();
                Assert.AreSame(logger, actual);
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper">
            <summary>
            Interface for performing object to object method call swapping
            </summary>
            <remarks>
            This interface is returned by calling Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)"/>. Follow it by calling
            the <see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)"/> completing statement.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)">
            <summary>
            Completes swapping method calls for an object. Is called as a completing statement for Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)"/>,
            and defines the target object to perform swapping on.
            </summary>
            <param name="swapped">The object whose implementation should be used</param>
            <returns>An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper"/> interface reference. </returns>
            <remarks>
            When a method is called on the swapped object, it is replaced with a corresponding implementation (a method
            with the same signature) on the swapping object. This means that the swapped object will start behaving like
            the object it was swapped with for all methods they have in common.
            <para>
            When a method is called on the swapped object that does not exist in the target object, it will be called on the original
            object.
            </para>
            </remarks>
            <exception cref="T:TypeMock.TypeMockException">
            If there are no compatible methods to swap between the swapping source and target objects.
            </exception>
            <example>
            This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)"/>.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)"/> in order to 
            redirect calls from an object to a stand-in object:
            <code>
            [TestMethod]
            [Isolated]
            public void SwapCallsOnObject_CallsRedirectedToTargetObject()
            {
                // Create the object under test
                RealLogger logger = new RealLogger();
                // Create the object calls will be redirected to
                TestLogger swapped = new TestLogger();
            
                // Redirect any calls from the object under test to the swapping target
                Isolate.Swap.CallsOn(logger).WithCallsTo(swapped);
            
                // logger.Write() is redirected to TestLogger.Write() which writes to console instead of disk
                logger.Write("Hello World");
            
                // We can still verify the call to logger.Write() happened
                Isolate.Verify.WasCalledWithAnyArguments(() => logger.Write(""));
            }
            
            // excerpt code for the class under test:
            public class RealLogger
            {
                string logFilePath = ...;
                public void Write(string toWrite)
                {
                    logFile.WriteAllText(logFilePath, toWrite);
                }
            }
            
            // excerpt code for the replacement class:
            public class TestLogger
            {
                public void Write(string toWrite)
                {
                    Console.WriteLine("RealLogger.Write() was called with {0}", toWrite);
                }
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IFaker">
            <summary>
            Interface for specifying fake object creation settings. The interface is typed by the preceeding <c>Fake</c> property.
            </summary>
            <remarks>
            This interface is returned by the <see cref="P:TypeMock.ArrangeActAssert.Isolate.Fake"/> property.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Dependencies``1(System.Object[])">
            <summary>
            Returns a new instance of T with all dependencies faked. 
            </summary>
            <typeparam name="T">The type to which all dependencies will be faked.</typeparam>
            <param name="constructorArguments">List of real arguments to pass to constructor</param>
            <returns>A new instance of type T.</returns>
            <remarks>
            To create an instance, where all the dependencies are fake, use Isolate.Fake.Dependencies.
            When the Type is created the longest constructor of T is called with fakes passed as arguments.
            if a list of constructorArguments is passed, these will be passed in the correct position (matched by type) to the constructor.
            All primitives are initialized to their base value, as well as structs. Strings are passed empty.
            </remarks>
            <example>
            Here is an example how to use Dependencies in order to fake all dependencies of a ClassUnderTest type:
            <code lang="cs">
            [TestMethod]
            [Isolated]
            public void FakeAllDependencies()
            {
                var real = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;();
                real.Log("Test");
                Assert.AreEqual(1, real.Count);
            }
            </code>
            if a list of constructorArguments is passed, these will be passed in the correct position (matched by type) to the constructor.
            Example, To fake all arguments of but use a real instance of MyType1
            <code lang="cs">
            public ClassUnderTest(int arg1, MyType1 arg2, MyInterface2 arg3)
            </code>
            Use
            <code lang="cs">
                var arg2 = new MyType1();
                var underTest = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;(arg2);
            </code>
            To modify a fake before the constructor is called, do the following
            <code lang="cs">
                var fake = Isolate.Fake&lt;MyType1&gt;();
                Isolate.WhenCalled(()=>fake.CrashTheSystem()).IgnoreCall();
                var underTest = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;(fake);
            </code>        
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.GetFake``1(System.Object)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1">
             <summary>
             Overloaded. Returns a fake instance of type T. Using this overload is equal to using <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes">Members.ReturnRecursiveFakes</see>.
             </summary>
             <typeparam name="T">The type of fake object to create.</typeparam>
             <returns>A fake instance of type T.</returns>
             <seealso cref="T:TypeMock.ArrangeActAssert.Members">Members Enum</seealso>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
             <example>
             Here is an example how to use Instance in order to fake a RealLogger instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 fake.Count = 0;
             
                 // This call is faked because we used the default Instance overload - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)">
             <summary>
             Overloaded. Returns a fake instance of type T.
             </summary>
             <remarks>
             </remarks>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <param name="behavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>Members</c> Value</term><description>Description</description></listheader>
             <item>
             <term><c>Members.MustSpecifyReturnValues</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnNulls</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
             </description>
             </item>
             <item>
             <term><c>Members.CallOriginal</c></term>
             <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnRecursiveFakes</c></term>
             <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description>
             </item>
             </list>
             </param>
             <returns>A fake instance of Type T.</returns>
             <seealso cref="T:TypeMock.TypeMockException"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
             <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.MustSpecifyReturnValues);
                 
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                 fake.Count = 0;
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls);
                 
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes);
            
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
             <summary>
             Overloaded. Returns a fake instance of type T.
             </summary>
             <remarks>
             </remarks>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <param name="behavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>Members</c> Value</term><description>Description</description></listheader>
             <item>
             <term><c>Members.MustSpecifyReturnValues</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnNulls</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
             </description>
             </item>
             <item>
             <term><c>Members.CallOriginal</c></term>
             <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnRecursiveFakes</c></term>
             <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description>
             </item>
             </list>
             </param>
             <param name="constructorBehavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
             </listheader>
             <item>
             <term><c>ConstructorWillBe.Ignored</c></term>
             <description>Constructor will not be executed when creating the fake object</description>
             </item>
             <item>
             <term><c>ConstructorWillBe.Called</c></term>
             <description>Execute Constructor when creating the fake object</description>
             </item>
             </list>
             </param>
             <returns>A fake instance of Type T.</returns>
             <seealso cref="T:TypeMock.TypeMockException"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
             <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.MustSpecifyReturnValues, ConstructorWillBe.Ignored);
                 
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal, ConstructorWillBe.Ignored);
                 
                 // Because constructor was not called Count was not initialized
                 Assert.AreEqual(0, fake.Count);
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls, ConstructorWillBe.Ignored);
                 
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 // We create a fake after running the real constructor that sets count field to 5
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, ConstructorWillBe.Called);
            
                 // Because Constructor was called fake.count field was initialized
                 Assert.AreEqual(5, fake.count);
             
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,System.Object[])">
             <summary>
             Overloaded. Returns a fake instance of type T.
             </summary>
             <remarks>
             </remarks>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <param name="behavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>Members</c> Value</term><description>Description</description></listheader>
             <item>
             <term><c>Members.MustSpecifyReturnValues</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnNulls</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
             </description>
             </item>
             <item>
             <term><c>Members.CallOriginal</c></term>
             <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnRecursiveFakes</c></term>
             <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description>
             </item>
             </list>
             </param>
             <param name="constructorBehavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
             </listheader>
             <item>
             <term><c>ConstructorWillBe.Ignored</c></term>
             <description>Constructor will not be executed when creating the fake object</description>
             </item>
             <item>
             <term><c>ConstructorWillBe.Called</c></term>
             <description>Execute Constructor when creating the fake object</description>
             </item>
             </list>
             </param>
             <param name="constructorArguments">
             The parameters to pass to a specific constructor. 
             If constructor behavior is set to <see cref="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored"/> and this value isn't empty a <see cref="T:TypeMock.TypeMockException"/> will be thrown
             </param>
             <returns>A fake instance of Type T.</returns>
             <seealso cref="T:TypeMock.TypeMockException"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
             <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.MustSpecifyReturnValues, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we&apos;ve passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count);
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal, ConstructorWillBe.Called, 10);
              
                 // Check that the value we&apos;ve passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count);   
             
                 // Because constructor was not called Count was not initialized
                 Assert.AreEqual(0, fake.Count);
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we&apos;ve passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count); 
             
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we&apos;ve passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count); 
             
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe)">
            <summary>
            Overloaded. Returns a fake instance of type T.
            </summary>
            <remarks>
            </remarks>
            <typeparam name="T">The type of the fake instance to be created.</typeparam>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
            <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
            </listheader>
            <item>
            <term><c>ConstructorWillBe.Ignored</c></term>
            <description>Constructor will not be executed when creating the fake object</description>
            </item>
            <item>
            <term><c>ConstructorWillBe.Called</c></term>
            <description>Execute Constructor when creating the fake object</description>
            </item>
            </list>
            </param>
            <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
            </param>
            <returns>A fake instance of Type T.</returns>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object (or other mscorlib types)
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
            <seealso cref="T:TypeMock.TypeMockException"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
            <example>
            The following test shows faking an instance without calling its base class&apos; constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Object[])">
            <summary>
            Overloaded. Returns a fake instance of type T.
            </summary>
            <remarks>
            </remarks>
            <typeparam name="T">The type of the fake instance to be created.</typeparam>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
            <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
            </listheader>
            <item>
            <term><c>ConstructorWillBe.Ignored</c></term>
            <description>Constructor will not be executed when creating the fake object</description>
            </item>
            <item>
            <term><c>ConstructorWillBe.Called</c></term>
            <description>Execute Constructor when creating the fake object</description>
            </item>
            </list>
            </param>
            <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
            </param>
            <param name="constructorArguments">        
            The parameters to pass to a specific constructor. 
            </param>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if <paramref name="constructorBehavior"/> is set to <see cref="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored"/> and parameter arguments are passed in <paramref name="constructorArguments"/>
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments"/>
            </exception>
            <returns>A fake instance of Type T.</returns>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
            <example>
            The following test shows faking an instance without calling its base class&apos; constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type)">
            <summary>
            Overloaded. Returns a fake instance of type T.
            </summary>
            <typeparam name="T">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </typeparam>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>
            All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> 
            on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
            <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
            </listheader>
            <item>
            <term><c>ConstructorWillBe.Ignored</c></term>
            <description>Constructor will not be executed when creating the fake object</description>
            </item>
            <item>
            <term><c>ConstructorWillBe.Called</c></term>
            <description>Execute Constructor when creating the fake object</description>
            </item>
            </list>
            </param>
            <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
            </param>
            <param name="baseTypeToIgnoreConstructor">
            The type of the base class who&apos;s constructor will be ignored.
            </param>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor"/>
            </exception>
            <returns>A fake instance of Type T.</returns>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
            <example>
            The following test shows faking an instance without calling its base class&apos; constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored,
                                                                   typeof(AbstractLoggerBase));
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type,System.Object[])">
            <summary>
            Overloaded. Returns a fake instance of type T.
            </summary>
            <typeparam name="T">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </typeparam>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>
            All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> 
            on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
            <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
            </listheader>
            <item>
            <term><c>ConstructorWillBe.Ignored</c></term>
            <description>Constructor will not be executed when creating the fake object</description>
            </item>
            <item>
            <term><c>ConstructorWillBe.Called</c></term>
            <description>Execute Constructor when creating the fake object</description>
            </item>
            </list>
            </param>
            <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
            </param>
            <param name="baseTypeToIgnoreConstructor">
            The type of the base class who&apos;s constructor will be ignored.
            </param>
            <param name="constructorArguments">        
            The parameters to pass to a specific constructor. 
            </param>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor"/>
            </exception>
            <exception cref="T:TypeMock.TypeMockException">
            Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments"/>
            </exception>
            <returns>A fake instance of Type T.</returns>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
            <example>
            The following test shows faking an instance without calling its base class&apos; constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored,
                                                                   typeof(AbstractLoggerBase));
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1">
            <summary>
             Overloaded. Fake future calls to static constructors of the given type.
            </summary>
            <typeparam name="T">The type for which to fake static constructor calls</typeparam>
             <exception cref="T:TypeMock.TypeMockException">
                 Thown if the static constructor for the provided type has already been called, if an 
                 instance fake of the type has already been created or if FakeStaticConstructors has already
                 been called for it.
             </exception>
             <remarks>
                 This overload for FakeStaticConstructor receives a generic parameter. Because static classes cannot be instantiated, they
                 also cannot be used as generic type parameters. In order to fake the static constructors for a static class, use the non
                 generic overload which receives a Type parameter.
             </remarks>
             <example>
             This example shows using Isolate.Fake.StaticConstructor() to fake a call to a static constructor
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticConstructor_CCtorNotCalled()
             {
                 Isolate.Fake.StaticConstructor&lt;TestClass&gt;()
             
                 TestClass.DoSomething(); // this causes the static constructor to be called
             
                 // the call to the static constructor was faked so the flag equals false   
                 Assert.IsFalse(TestClass.TrueIfCCtorHappened); 
             }
             </code>
             </example>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor(System.Type)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor(System.Type)">
            <summary>
             Overloaded. Fake future calls to static constructors of the given type.
            </summary>
            <param name="type">The type for which to fake static constructor calls</param>
             <exception cref="T:TypeMock.TypeMockException">
                 Thrown if the static constructor for the provided type has already been called, if an 
                 instance fake of the type has already been created or if FakeStaticConstructors has already
                 been called for it.
             </exception>
             <remarks>
                 This overload for FakeStaticConstructor receives a Type parameter which represents the class to fake static constructors for,
                 and should be used when faking constructors for static classes. For other non-static classes it is generally recommended to use the 
                 generic overload <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1"/>, which receives the class as a generic type argument.
             </remarks>        
             <example>
             This example shows using Isolate.Fake.StaticConstructor() to fake a call to a static constructor
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticConstructor_CCtorNotCalled()
             {
                 Isolate.Fake.StaticConstructor( typeof(StaticTestClass))
             
                 StaticTestClass.DoSomething(); // this causes the static constructor to be called
             
                 // the call to the static constructor was faked so the flag equals false   
                 Assert.IsFalse(StaticTestClass.TrueIfCCtorHappened); 
             }
             </code>
             </example>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1">
            <summary>
            Overloaded. Fakes all static methods for type T. Using this overload is equal to using <c>Members.MustSpecifyReturnValues</c>.
            </summary>
            <typeparam name="T">The type to fake static methods for.</typeparam>
            <seealso cref="T:TypeMock.ArrangeActAssert.Members">Members Enum</seealso>
            <remarks>
            Static class cannot be used as type argument.
            Use IFaker.StaticMethods(Type type) or IFaker.StaticMethods(Type type, Members behavior) instead.
            </remarks>
            <example>
            This example shows using FakeStaticMethods to stub all static void calls for a class
            <code lang="cs">
            [TestMethod]
            [Isolated]
            public void FakeStaticMethods_StubIncrementMethod()
            {
                Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
            
                LoggerFactory.Count = 0;
                // This call is faked because we used the default overload for FakeStaticMethods - 
                // IncrementCount() is not really performed
                LoggerFactory.IncrementCount();
            
                Assert.AreEqual(0, LoggerFactory.Count);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods(System.Type)">
            <summary>
            Overloaded. Fakes all static methods for the provided type. Using this overload is equal to using <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes">Members.ReturnRecursiveFakes</see>.
            </summary>
            <param name="type">The type to fake static methods for.</param>
            <seealso cref="T:TypeMock.ArrangeActAssert.Members">Members Enum</seealso>
            <remarks>
                This overload receives a Type parameter representing the class to fake static methods for, and should be used 
                when faking methods for static classes. For other non-static classes it is generally recommended to use the 
                generic overload <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1"/>, which receives the class as a generic type argument.
            </remarks>
            <example>
            This example shows using FakeStaticMethods to stub all static void calls for a class
            <code lang="cs">
            [TestMethod]
            [Isolated]
            public void FakeStaticMethods_StubIncrementMethod()
            {
                Isolate.Fake.StaticMethods( typeof(LoggerFactory));
            
                LoggerFactory.Count = 0;
                // This call is faked because we used the default overload for FakeStaticMethods - 
                // IncrementCount() is not really performed
                LoggerFactory.IncrementCount();
            
                Assert.AreEqual(0, LoggerFactory.Count);
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)">
             <summary>
             Overloaded. Fakes all static methods for type <typeparamref name="T"/>.
             </summary>
             <typeparam name="T">The type to fake static methods for.</typeparam>
             <param name="behavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>Members</c> Value</term><description>Description</description></listheader>
             <item>
             <term><c>Members.MustSpecifyReturnValues</c></term>
             <description>Default. All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnNulls</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
             </description>
             </item>
             <item>
             <term><c>Members.CallOriginal</c></term>
             <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnRecursiveFakes</c></term>
             <description>All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description>
             </item>
             </list>
             </param>
             <returns>A fake instance of Type T.</returns>
             <remarks>
             Static class cannot be used as type argument.
             Use IFaker.StaticMethods(Type type) or IFaker.StaticMethods(Type type, Members behavior) instead.
             </remarks>        
             <seealso cref="T:TypeMock.TypeMockException"/>
             <seealso cref="T:TypeMock.ArrangeActAssert.Members"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)"/>
             <example>
             The following test shows the default behavior of FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseDefault()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
             
                 LoggerFactory.Count = 0;
                 // This call is faked because we used the default overload for FakeStaticMethods - 
                 // IncrementCount() is not really performed
                 LoggerFactory.IncrementCount();
             
                 Assert.AreEqual(0, LoggerFactory.Count);
             
                 // The following statement will throw, because we didn't set behavior on GetCount() method.
                 int x = LoggerFactory.GetCount();
             }
             </code>
             The next test shows the CallOriginal setting for FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseCallOriginal()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;(Members.CallOriginal);
                 
                 LoggerFactory.Count = 0;
             
                 // This call is not faked. Count should be incremented.
                 LoggerFactory.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseReturnNulls()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;(Members.ReturnNulls);
                 
                 LoggerFactory.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 LoggerFactory.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(LoggerFactory.GetLogger());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code lang="cs">
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;(Members.ReturnRecursiveFakes);
            
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, LoggerFactory.GetLoggerCount());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(LoggerFactory.GetLogger());
             
                 // And the result of GetLogger also returns a non-null object 
                 Assert.IsNotNull(LoggerFactory.GetLogger().GetWriter());
            }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods(System.Type,TypeMock.ArrangeActAssert.Members)">
             <summary>
             Overloaded. Fakes all static methods for the given type.
             </summary>
             <param name="type">The type to fake static methods for.</param>
             <param name="behavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>Members</c> Value</term><description>Description</description></listheader>
             <item>
             <term><c>Members.MustSpecifyReturnValues</c></term>
             <description>Default. All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnNulls</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
             </description>
             </item>
             <item>
             <term><c>Members.CallOriginal</c></term>
             <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnRecursiveFakes</c></term>
             <description>All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description>
             </item>
             </list>
             </param>
             <returns>A fake instance of Type T.</returns>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)"/>
             <seealso cref="T:TypeMock.TypeMockException"/>
             <seealso cref="T:TypeMock.ArrangeActAssert.Members"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)"/>
             <remarks>
                 This overload receives a Type parameter representing the class to fake static methods for, and should be used 
                 when faking methods for static classes. For other non-static classes it is generally recommended to use the 
                 generic overload <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)"/>, which receives the class as a generic type argument.
             </remarks>
             <example>
             The following test shows the default behavior of FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseDefault()
             {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory));
             
                 LoggerFactory.Count = 0;
                 // This call is faked because we used the default overload for FakeStaticMethods - 
                 // IncrementCount() is not really performed
                 LoggerFactory.IncrementCount();
             
                 Assert.AreEqual(0, LoggerFactory.Count);
             
                 // The following statement will throw, because we didn't set behavior on GetCount() method.
                 int x = LoggerFactory.GetCount();
             }
             </code>
             The next test shows the CallOriginal setting for FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseCallOriginal()
             {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory), Members.CallOriginal);
                 
                 LoggerFactory.Count = 0;
             
                 // This call is not faked. Count should be incremented.
                 LoggerFactory.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseReturnNulls()
             {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory), Members.ReturnNulls);
                 
                 LoggerFactory.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 LoggerFactory.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(LoggerFactory.GetLogger());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code lang="cs">
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory), Members.ReturnRecursiveFakes);
            
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, LoggerFactory.GetLoggerCount());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(LoggerFactory.GetLogger());
             
                 // And the result of GetLogger also returns a non-null object 
                 Assert.IsNotNull(LoggerFactory.GetLogger().GetWriter());
            }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1">
             <summary>
             Overloaded. Fake a future instance of type T.
             </summary>
             <returns>An object of type T which is used as a faking handle.</returns>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.NextInstance&lt;RealLogger&gt;();
            
                 Isolate.WhenCalled(() => fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code>
             </example>
             <note>
             The constructor of the next instance will be ignored.
             </note>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(TypeMock.ArrangeActAssert.Members)">
            <summary>
            Overloaded. Fake a future instance of type T.
            </summary>
            <returns>An object of type T which is used as a mocking handle.</returns>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
            <summary>
            Overloaded. Fake a future instance of type T.
            </summary>
            <returns>An object of type T which is used as a faking handle.</returns>
            <typeparam name="T">The type of the fake instance to be created.</typeparam>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
            <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
            </listheader>
            <item>
            <term><c>ConstructorWillBe.Ignored</c></term>
            <description>Constructor will not be executed when creating the fake object</description>
            </item>
            <item>
            <term><c>ConstructorWillBe.Called</c></term>
            <description>Execute Constructor when creating the fake object</description>
            </item>
            </list>
            </param>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(TypeMock.ArrangeActAssert.Members,System.Action{TypeMock.MethodCallContext})">
             <summary>
             Overloaded. Fakes the next instance of type T, and allows to add code to run before the constructor.
             </summary>
             <returns>An object of type T which is used as a faking handle.</returns>
             <param name="behavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>Members</c> Value</term><description>Description</description></listheader>
             <item>
             <term><c>Members.MustSpecifyReturnValues</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnNulls</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
             </description>
             </item>
             <item>
             <term><c>Members.CallOriginal</c></term>
             <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnRecursiveFakes</c></term>
             <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description>
             </item>
             </list>
             </param>
             <param name="doInstead">The action to run at the start of the constructor.</param>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.NextInstance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, context => flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code>
             </example>
             <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(System.Action{TypeMock.MethodCallContext})">
             <summary>
             Overloaded. Fakes the next instance of type T, and allows to add code to run before the constructor.
             </summary>
             <returns>An object of type T which is used as a faking handle.</returns>
             <param name="doInstead">The action to run at the start of the constructor.</param>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.NextInstance&lt;RealLogger&gt;(context => flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code>
             </example>
             <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1">
             <summary>
             Overloaded. Fakes all instances of type T.
             </summary>
             <returns>An object of type T which is used as a faking handle.</returns>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.AllInstances&lt;RealLogger&gt;();
            
                 Isolate.WhenCalled(() => fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code>
             </example>
             <note>
             The constructor will be ignored.
             </note>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(TypeMock.ArrangeActAssert.Members)">
            <summary>
            Overloaded. Fakes all instances of type T.
            </summary>
            <returns>An object of type T which is used as a mocking handle.</returns>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
            <summary>
            Overloaded. Fakes all instances of type T.
            </summary>
            <returns>An object of type T which is used as a mocking handle.</returns>
            <typeparam name="T">The type of the fake instance to be created.</typeparam>
            <param name="behavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>Members</c> Value</term><description>Description</description></listheader>
            <item>
            <term><c>Members.MustSpecifyReturnValues</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnNulls</c></term>
            <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
            </description>
            </item>
            <item>
            <term><c>Members.CallOriginal</c></term>
            <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
            </description>
            </item>
            <item>
            <term><c>Members.ReturnRecursiveFakes</c></term>
            <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description>
            </item>
            </list>
            </param>
            <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table">
            <listheader>
            <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
            </listheader>
            <item>
            <term><c>ConstructorWillBe.Ignored</c></term>
            <description>Constructor will not be executed when creating the fake object</description>
            </item>
            <item>
            <term><c>ConstructorWillBe.Called</c></term>
            <description>Execute Constructor when creating the fake object</description>
            </item>
            </list>
            </param>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(TypeMock.ArrangeActAssert.Members,System.Action{TypeMock.MethodCallContext})">
             <summary>
             Overloaded. Fakes all instances of type T, and allows to add code to run before the constructor.
             </summary>
             <returns>An object of type T which is used as a faking handle.</returns>
             <param name="behavior">
             Can be one of the following values:
             <list type="table">
             <listheader>
             <term><c>Members</c> Value</term><description>Description</description></listheader>
             <item>
             <term><c>Members.MustSpecifyReturnValues</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnNulls</c></term>
             <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
             </description>
             </item>
             <item>
             <term><c>Members.CallOriginal</c></term>
             <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
             </description>
             </item>
             <item>
             <term><c>Members.ReturnRecursiveFakes</c></term>
             <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description>
             </item>
             </list>
             </param>
             <param name="doInstead">The action to run at the start of the constructor.</param>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAllInstances_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.AllInstances&lt;RealLogger&gt;(context => flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code>
             </example>
             <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(System.Action{TypeMock.MethodCallContext})">
             <summary>
             Overloaded. Fakes all instances of type T, and allows to add code to run before the constructor.
             </summary>
             <returns>An object of type T which is used as a faking handle.</returns>
             <param name="doInstead">The action to run at the start of the constructor.</param>
             <typeparam name="T">The type of the fake instance to be created.</typeparam>
             <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAllInstances_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.AllInstances&lt;RealLogger&gt;(context => flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code>
             </example>
             <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IHideObjectMethods">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic">
            <summary>
            Returned by <seealso cref="P:TypeMock.ArrangeActAssert.Isolate.NonPublic"/>, this interface contains methods for faking and setting 
            behavior for method calls on non public methods, properties and indexers.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])">
             <summary>
             Sets behavior for a specific method on a an object
             </summary>
             <param name="targetObject">The object to set method behavior on.</param>
             <param name="methodName">The name of a method to set behavior on.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/></remarks>
             <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a private call:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateMethod_DoNotWriteToDisk()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Avoid performing actual write to disk by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled(fake, "WriteToDisk").IgnoreCall();
             
                 // The private call is stubbed so no actual disk writes are performed
                 fake.Log("Hello World");
            
                 Assert.AreEqual(1, fake.LineCount);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Type,System.String)">
             <summary>
             Sets behavior for a specific static method on a class
             </summary>
             <param name="type">The type to set method behavior on. Applies to static methods.</param>
             <param name="methodName">The name of a static method to set behavior on.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/></remarks>
             <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a private call:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateStaticMethod_FactoryCreate()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
                 
                 // Avoid performing to network access by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled(typeof(LoggerFactory), "ReportToControllerServer").IgnoreCall();
             
                 // The private method is stubbed and the unit test will not perform external calls
                 RealLogger logger = LoggerFactory.CreateLogger();
            
                 Assert.IsNotNull(logger);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled``1(System.String)">
             <summary>
             Sets behavior for a specific static method on a class
             </summary>
             <typeparam name="T">The type to set method behavior on. Applies to static methods.</typeparam>
             <param name="methodName">The name of a static method to set behavior on.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/></remarks>
             <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a private call:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateStaticMethod_FactoryCreate()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
                 
                 // Avoid performing to network access by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled&lt;LoggerFactory&gt;("ReportToControllerServer").IgnoreCall();
             
                 // The private method is stubbed and the unit test will not perform external calls
                 RealLogger logger = LoggerFactory.CreateLogger();
            
                 Assert.IsNotNull(logger);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Property">
            <summary>
            A read only property, used to set behavior on non-public properties
            </summary>
            <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder"/> reference
            </returns>
            <remarks>
            Because of the nature of fluent interface, you need to use Property with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder"/>.
            <para>
            When handling non public (private, protected, internal) properties all access to property names is string-based.
            </para>
            </remarks>
            <example>
            This example shows how to use Isolate.NonPublic.Property in order to set behavior on a private property getter:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivatePropertyBehavior_ChangeReturnValue()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                
                // have private RealLogger.IsDiskFull property return true to simulate an error
                Isolate.NonPublic.Property.WhenCalledGet(fake, "IsDiskFull").WillReturn(true);
            
                // Because we simulated a disk full error, this call should throw an exception
                try
                {
                    fake.Log("Hello World");
                    Assert.Fail("fake.Log() should have thrown because IsDiskFull is true");
                }
                catch(OutOfDiskSpaceException)
                {
                }
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder"/>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Indexer">
            <summary>
            A read only property, used to set behavior on non-public indexers
            </summary>
            <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder"/> reference
            </returns>
            <remarks>
            Because of the nature of fluent interface, you need to use Indexer with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder"/>.
            </remarks>
            <example>
            This example shows how to use Isolate.NonPublic.Indexer in order to set behavior on a private index getter:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivateIndexBehavior_ChangeReturnValue()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                // have private LogFile[i] index return a specified log line
                Isolate.NonPublic.Indexer.WhenCalledGet(fake).WillReturn("Info: this is a test log line");
            
                // We set the value of the next log line the internal implementation will look at
                Assert.AreEqual("this is a test log line", fake.GetNextLogLine(Level.Info));
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.CreateInstance``1(System.Object[])">
            <summary>
            Creates a live instance of a class that does not have a public constructor
            </summary>
            <typeparam name="T">The type of the instance to create</typeparam>
            <param name="parameters">The argument list to pass to the matching constructor</param>
            <returns>A live instance of type T</returns>
            <remarks>
            A factory method, used to create a real live instance of a type that doesn't expose a public constructor. The types of the arguments 
            in the argument list determines which non-public constructor will be called.
            </remarks>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder">
            <summary>
            Returned by Isolate.NonPublic.<seealso cref="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Indexer"/>, this interface contains methods for faking and setting 
            behavior for non-public (private, protected and internal) index get and set calls
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder.WhenGetCalled(System.Object)">
             <summary>
             Sets specific behavior for a non-public index getter on a an object
             </summary>
             <param name="fake">The object to set indexer behavior for.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenGetCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>.</remarks>
             <example>
             Here is an example how to use Isolate.NonPublic.Indexer.WhenGetCalled() in order to set return value for an index call:
             <code>
             [TestMethod]
             [Isolated]
             public void ChangeIndexGetReturnValue()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;LogContainer&gt;();
                 
                 // Set the internal indexer to return a specific value
                 Isolate.NonPublic.Indexer.WhenGetCalled(fake).WillReturn("hello");
             
                 // The object under test uses the private index get result as part of a calculation
                 string result = fake.GetStringAt(10);
                 Assert.AreEqual("hello", result);
             }
             
             // Excerpt from class under test
             public class LogContainer
             {
                 // method under test
                 public string GetStringAt(int line)
                 {
                     return this[line];
                 }
            
                 private string fileName = ...
             
                 // private indexer
                 private string this[int line]
                 {
                     get { return ReadFromFile(fileName, line); }
                 }
             
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder.WhenSetCalled(System.Object)">
             <summary>
             Sets specific behavior for a non-public index set on a an object
             </summary>
             <param name="fake">The object to set indexer behavior for.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenSetCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/>.</remarks>
             <example>
             Here is an example how to use Isolate.NonPublic.Indexer.WhenSetCalled() in order to simulate a memory error on index write access:
             <code>
             [TestMethod]
             [Isolated]
             [ExpectedException(typeof(OutOfMemoryException))
             public void ThrowExceptionFromIndexSet_SimulateMemoryError()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;LogContainer&gt;();
                 
                 // Set the internal indexer to throw an exception on set
                 Isolate.NonPublic.Indexer.WhenSetCalled(fake).WillThrow(new OutOfMemoryException());
             
                 // The object under test uses the private index setter when writing to log
                 fake.WriteToLog("hello");
             }
             
             // Excerpt from class under test
             public class LogContainer
             {
                 // method under test
                 public string WriteToLog(string message)
                 {
                     this[currentLine] = message;
                     currentLine++;
                 }
            
                 private string fileName = ...
                 private int currentLine = 0;
             
                 // private indexer
                 private string this[int line]
                 {
                     set { InternalWrite(fileName, line, value); }
                 }
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder">
            <summary>
            Returned by Isolate.NonPublic.<seealso cref="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Property"/>, this interface contains methods for faking and setting 
            behavior for non-public (private, protected and internal) property get and set calls
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenGetCalled(System.Object,System.String)">
            <summary>
            Sets specific behavior for a non-public property getter on an object
            </summary>
            <param name="fake">The object to set property behavior for.</param>
            <param name="propertyName">The name of a property to set behavior on.</param>
            <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>Property.WhenGetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>.</remarks>
            <example>
            Here is an example how to use Property.WhenGetCalled in order to set return value on a private property:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedExcetion(typeof(OutOfDiskSpaceException))]
            public void ChangePrivatePropertyReturnValue_SimulateDiskError()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Set the behavior on the internal IsDiskFull property to true
                Isolate.NonPublic.Property.WhenGetCalled(fake, "IsDiskFull").WillReturn(true);
            
                // The fake object checks the disk is full before logging and throws an exception
                fake.Log("Hello World");
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                // method under test
                public override void Log(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
                    
                    AppendToFile(fileName, message);
                }
            
                private bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenGetCalled(System.Type,System.String)">
            <summary>
            Sets specific behavior for a non-public static property getter for a class type
            </summary>
            <param name="type">The type to set static property getter behavior on. Applies to static methods.</param>
            <param name="propertyName">The name of a property to set behavior on.</param>
            <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>Property.WhenGetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>.</remarks>
            <example>
            Here is an example how to use Property.WhenGetCalled in order to set return value on a private property:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfDiskSpaceException))]
            public void ChangePrivatePropertyReturnValue_SimulateDiskError()
            {
                Isolate.Fake.StaticMethods&lt;RealLogger&gt;();
                
                // Set the behavior on the internal IsDiskFull property to true
                Isolate.NonPublic.Property.WhenGetCalled(typeof(RealLogger), "IsDiskFull").WillReturn(true);
            
                RealLogger logger = new RealLogger();
                
                // The logger object calls the static property to find out if the disk is full before logging and throws an exception
                logger.Log("Hello World");
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                // method under test
                public static override void Log(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
                    
                    AppendToFile(fileName, message);
                }
            
                private static bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenSetCalled(System.Object,System.String)">
            <summary>
            Sets specific behavior for a non-public property setter on an object
            </summary>
            <param name="fake">The object to set property behavior for.</param>
            <param name="propertyName">The name of a property to set behavior on.</param>
            <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>Property.WhenSetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>.</remarks>
            <example>
            Here is an example how to use Property.WhenSetCalled in order to simulate an error by throwing an exception
            on an internal property setter call:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfDiskSpaceException))]
            public void ThrowExceptionFromPrivatePropertySetter_SimulateDiskError()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Set the behavior of the internal CurrentLine property to throw an exception when set
                Isolate.NonPublic.Property.WhenSetCalled(fake, "CurrentLine").WillThrow(new OutOfDiskSpaceException());
            
                // The object under test tries to log to its internal container and fails because of the exception we set
                fake.Log("Hello World");
            }
            
            // Excerpt from classes under test
            public class RealLogger : ILogger
            {
                private string fileName;
                // method under test
                public static override void Log(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
                    
                    CurrentLine = message;
                }
            
                private static bool IsDiskFull
                {
                    get { return ...; }
                }
            
                internal string CurrentLine
                {
                    get { return current; }
                    set { WriteToLogFile(value); current = value; }
                }
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenSetCalled(System.Type,System.String)">
            <summary>
            Sets specific behavior for a non-public static property setter for a class 
            </summary>
            <param name="type">The type to set static property setter behavior on. Applies to static methods.</param>
            <param name="propertyName">The name of a property to set behavior on.</param>
            <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>Property.WhenSetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>.</remarks>
            <example>
            Here is an example how to use Property.WhenSetCalled in order to simulate an error by throwing an exception
            on an internal property setter call:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfMemoryException))]
            public void ThrowExceptionFromPrivatePropertySetter_SimulateMemoryFull()
            {
                Isolate.Fake.Instance&lt;LogContainer&gt;();
                
                // Set the behavior on the internal IsDiskFull property to true
                Isolate.NonPublic.Property.WhenSetCalled(typeof(LogContainer), "Cache").WillThrow(new OutOfMemoryException());
            
                // The object under test tries to log using the LogContainer.Cache internal container and fails because of the exception we set
                fake.Log("Hello World");
            }
            
            // Excerpt from class under test:
            public class LogContainer
            {
                public void Log(string message)
                {
                    LogContainer.Cache.Add(message);
                    WriteToDisk(message);
                }
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)"/>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler">
            <summary>
            Returned by Isolate.NonPublic.<see cref="!:IIsolateNonPublic.WhenCalled(object,string)"/>, this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.OnBase(System.Type)">
            <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
            <remarks>
            <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
            <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
            </remarks>
            <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // ignore only base method
                Isolate.NonPublic.WhenCalled(fake,"VirtualMethod").OnBase(typeof(BaseLogger)).IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.OnBase">
            <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
            <remarks>
            <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
            </remarks>
            <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // ignore only base method
                Isolate.WhenCalled(() => fake.VirtualMethod(0)).OnBase().IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.WithGenericArguments(System.Type,System.Type[])">
             <summary>
             Specifies generic type arguments that apply to a non-public method to set behavior on. The behavior will 
             be set only for a method bound to the passed type arguments
             </summary>
             <param name="genericType">The first generic type argument the method binds to</param>
             <param name="additionalGenericTypes">Optional. Further generic type arguments the method binds to.</param>
             <returns>an INonPublicMethodBehavior interface reference</returns>
             <remarks>
             WithGenericArguments() modifies a call to Isolate.NonPublic.<see cref="!:IIsolateNonPublic.WhenCalled(object,string)"/>.
             Due to the fluent nature of the AAA API it should be used with its proceeding methods; see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior"/>.
             </remarks>
             <example>
             Here is an example how to use WhenCalled with WithGenericArguments in order to simulate an error creating
             a factory generated object:
             <code>
             [TestMethod]
             [Isolated]
             public void ThrowExceptionFromGenericMethod_SimulateErrorCreatingLogger()
             {
                 LoggerFactory fake = Isolate.Fake.Instance&lt;LoggerFactory&gt;();
                 
                 // Set the logger factory to throw an exception when trying to retrieve a RealLogger
                 Isolate.NonPublic.WhenCalled(fake, "GetLogger").
                     WithGenericArguments(typeof(RealLogger)).
                     WillThrow(new ArgumentNullException());
             
                 // The following method call is not faked because it does not match the specified generic 
                 // type arguments - no exception is thrown
                 DiskLogger logger = fake.GetLogger&lt;DiskLogger&gt;();
            
                 // This call will throws an exception as specified
                 try 
                 {
                     fake.GetLogger&lt;RealLogger&gt;();
                     Assert.Fail("Retrieving a RealLogger should have failed with an ArgumentNullException");
                 }
                 catch(ArgumentNullException)
                 {
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.AssignRefOut(System.Object[])">
            <summary>
            Assigns return values of ref and out arguments of a non-public method to set behavior on. 
            </summary>
            <param name="fakeOutRef">list of values corrisponding to ref and out parameters </param>
            <returns>an INonPublicMethodHandler interface reference</returns>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicArgHandler">
            <summary>
            Returned by Isolate.NonPublic.<see cref="!:IIsolateNonPublic.WhenCalled(object,string)"/>, this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicArgHandler.WithGenericArguments(System.Type,System.Type[])">
             <summary>
             Specifies generic type arguments that apply to a non-public method to set behavior on. The behavior will 
             be set only for a method bound to the passed type arguments
             </summary>
             <param name="genericType">The first generic type argument the method binds to</param>
             <param name="additionalGenericTypes">Optional. Further generic type arguments the method binds to.</param>
             <returns>an INonPublicMethodBehavior interface reference</returns>
             <remarks>
             WithGenericArguments() modifies a call to Isolate.NonPublic.<see cref="!:IIsolateNonPublic.WhenCalled(object,string)"/>.
             Due to the fluent nature of the AAA API it should be used with its proceeding methods; see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior"/>.
             </remarks>
             <example>
             Here is an example how to use WhenCalled with WithGenericArguments in order to simulate an error creating
             a factory generated object:
             <code>
             [TestMethod]
             [Isolated]
             public void ThrowExceptionFromGenericMethod_SimulateErrorCreatingLogger()
             {
                 LoggerFactory fake = Isolate.Fake.Instance&lt;LoggerFactory&gt;();
                 
                 // Set the logger factory to throw an exception when trying to retrieve a RealLogger
                 Isolate.NonPublic.WhenCalled(fake, "GetLogger").
                     WithGenericArguments(typeof(RealLogger)).
                     WillThrow(new ArgumentNullException());
             
                 // The following method call is not faked because it does not match the specified generic 
                 // type arguments - no exception is thrown
                 DiskLogger logger = fake.GetLogger&lt;DiskLogger&gt;();
            
                 // This call will throws an exception as specified
                 try 
                 {
                     fake.GetLogger&lt;RealLogger&gt;();
                     Assert.Fail("Retrieving a RealLogger should have failed with an ArgumentNullException");
                 }
                 catch(ArgumentNullException)
                 {
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicArgHandler.AssignRefOut(System.Object[])">
            <summary>
            Assigns return values of ref and out arguments of a non-public method to set behavior on. 
            </summary>
            <param name="fakeOutRef">list of values corrisponding to ref and out parameters </param>
            <returns>an INonPublicMethodHandler interface reference</returns>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior">
            <summary>
            Returned by Isolate.NonPublic.<see cref="!:IIsolateNonPublic.WhenCalled(object,string)"/>, and 
            Isolate.NonPublic.WhenCalled().<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.WithGenericArguments(System.Type,System.Type[])"/>. this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehaviorNoArgs">
            <summary>
            Returned by Isolate.NonPublic.<see cref="!:IIsolateNonPublic.WhenCalled(object,string)"/>, and 
            Isolate.NonPublic.WhenCalled().<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.WithGenericArguments(System.Type,System.Type[])"/>. this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehaviorNoArgs.ReturnRecursiveFake``1">
            <summary>
            Specify that the intercepted method will return a recursive fake of a defined reference type.
            The real implementation will not be executed.
            </summary>
            <typeparam name="T">
            Type of the recursive fake to return
            </typeparam>
            <remarks>
            <para>
            ReturnRecursiveFake&lt;T&gt;() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/>. It
            is similar to using the <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes"/> behavior setting when creating 
            fake objects with <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>, but applies only to a single method.
            </para>
            Use ReturnRecursiveFake&lt;T&gt;() on a method to fake out calls to the method and any call chains 
            beginning with it. When ReturnRecursiveFake&lt;T&gt;() is called on a method returning an object, 
            a fake object of type <typeparamref name="T"/> will be returned. That fake object in turn will return fake values for any 
            method calls. 
            ReturnRecursiveFake&lt;T&gt;() on a method returning a value type will set the method to return 
            the default value of that type. 
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>
            <seealso cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes"/>
            <example>
            This example shows using ReturnRecursiveFake&lt;T&gt;() to fake out a call chain
            <code>
            [TestMethod]
            [Isolated]
            public void ReturnRecursiveFake_ChainedCallsAreFake()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // exclude one method from the default behavior and return a recursive fake from it
                // calling the method will return a fake of the derived class FileStorage
                Isolate.NonPublic.WhenCalled(fake, "InternalMethod").ReturnRecursiveFake&lt;FileStorage&gt;();
            
                // subsequent calls to the method will not return null values
                // Act...
                var result = ClassUnderTest.CallInternalMethod();    
            
                // Assert
                Assert.AreEqual(10,result);
            }
            </code>
            </example>
            <returns>The fake object that will be returned. WhenCalled should be used on this object to setup specific behavior.</returns>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier">
            <summary>
            Returned by Isolate.Verify.<see cref="!:IVerifyHandler.NonPublic"/>, this interface contains methods for verifying non
            public (private, protected and internal) method, property and index calls, and checking argumentrs.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Object,System.String)">
            <summary>
            Overloaded. Verifies that a non-public method has been called
            </summary>
            <param name="targetObject">The fake object to verify method behavior on</param>
            <param name="methodName">The method to verify behavior for</param>
            <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments"/> interface reference, used to add argument checking</returns>
            <remarks>
            In order to perform additional argument checking as part of the verification, use the proceeding <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])"/>
            method.
            </remarks>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was not called.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the internal call to WriteToDisk() was performed with correct arguments
               Isolate.Verify.NonPublic.WasCalled(fake, "WriteToDisk").WithArguments("Hello");
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Type,System.String)">
            <summary>
            Overloaded. Verifies that a non-public static method has been called
            </summary>
            <param name="type">The type to verify static method behavior on</param>
            <param name="methodName">The method to verify behavior for</param>
            <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments"/> interface reference, used to add argument checking</returns>
            <remarks>
            In order to perform additional argument checking as part of the verification, use the proceeding <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])"/>
            method.
            </remarks>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was not called.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a static method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyStaticMethodWasCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger("logfile.txt", Access.ReadWrite);
            
               // Verify the call to internal method LoggerFactory.GetRealLogger() has been made
               Isolate.Verify.NonPublic.WasCalled(typeof(LoggerFactory), "GetRealLogger").
                    WithArguments("logfile.txt", Access.ReadWrite); 
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Type,System.String,System.Type[])">
            <summary>
            Overloaded. Verifies that a non-public static generic method has been called
            </summary>
            <param name="type">The type to verify static method behavior on</param>
            <param name="methodName">The method to verify behavior for</param>
            <param name="methodGenericArguments">Array of type arguments for the generic method</param>
            <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments"/> interface reference, used to add argument checking</returns>
            <remarks>
            In order to perform additional argument checking as part of the verification, use the proceeding <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])"/>
            method.
            </remarks>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was not called.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a static generic method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyStaticMethodWasCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger("logfile.txt", Access.ReadWrite);
            
               // Verify the call to internal method LoggerFactory.GetRealLogger() has been made
               Isolate.Verify.NonPublic.WasCalled(typeof(LoggerFactory), "GetRealLogger", typeof(int)); 
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasNotCalled(System.Object,System.String)">
            <summary>
            Overloaded. Verifies that a non-public method was not called regardless of parameters.
            </summary>
            <param name="fake">The fake object to verify method behavior on</param>
            <param name="methodName">The method to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was called at least once.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello world!");
            
               // The logger write was called, so an internal WriteToDisk() was performed - 
               // this verification should fail
               Isolate.Verify.NonPublic.WasNotCalled(fake, "WriteToDisk"); 
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasNotCalled(System.Type,System.String)">
            <summary>
            Overloaded. Verifies that a non-public static method was not called regardless of parameters.
            </summary>
            <param name="type">The type to verify static method behavior on</param>
            <param name="methodName">The method to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was called at least once.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // We retrieved a RealLogger and an internal call to GetRealLogger() was made - 
               // this verification should fail
               Isolate.Verify.NonPublic.WasNotCalled(typeof(LoggerFactory), "GetRealLogger"); 
            }
            </code>
            </example>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Property">
            <summary>
            A read only property, used to verify calls on non-public properties
            </summary>
            <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier"/> reference
            </returns>
            <remarks>
            Because of the nature of fluent interface, you need to use Property with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier"/>.
            <para>
            When handling non public (private, protected, internal) properties all access to property names is string-based.
            </para>
            </remarks>
            <example>
            This example shows how to use Isolate.NonPublic.Property in order to verify the behavior of a private property getter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                
                fake.Log("Hello World");
            
                // Verify an internal disk space check was performed
                Isolate.Verify.NonPublic.Property.WasCalledGet(fake, "IsDiskFull");
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier"/>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Indexer">
            <summary>
            A read only property, used to verify calls on non-public indexers
            </summary>
            <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier"/> reference
            </returns>
            <remarks>
            Because of the nature of fluent interface, you need to use Indexer with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier"/>.
            </remarks>
            <example>
            This example shows how to use Isolate.NonPublic.Indexer in order to verify behavior on a private index setter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyIndexSetterWasCalled()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                fake.Write("Hello");
            
                // Verify a set call to the LogFile's internal indexer was made
                Isolate.Verify.NonPublic.Indexer.WasSetCalled(fake);
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier"/>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier">
            <summary>
            Returned by Isolate.Verify.NonPublic.<see cref="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Property"/>, this interface contains methods for verifying non
            public (private, protected and internal) properties
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledGet(System.Object,System.String)">
            <summary>
            Overloaded. Verifies that a non-public property getter has been called
            </summary>
            <param name="fake">The fake object to verify property behavior on</param>
            <param name="propertyName">The non-public property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property get was not called.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a private property
            get has been called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the private property IsDiskFull has been called
               Isolate.Verify.NonPublic.Property.WasCalledGet(fake, "IsDiskFull");
            }
            
            // Exceprt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                public void override Write(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
            
                    WriteToFile(fileName, message);
                }
            
                private bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledGet(System.Type,System.String)">
            <summary>
            Overloaded. Verifies that a non-public static property getter has been called
            </summary>
            <param name="type">The type to verify static property get behavior on</param>
            <param name="propertyName">The non-public property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property get was not called.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private property
            get has been called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // Verify the private property DoesLoggerExist has been called
               Isolate.Verify.NonPublic.Property.WasCalledGet(typeof(LoggerFactory), "DoesLoggerExist");
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                private ILogger logger;
                public ILogger GetLogger()
                {
                    if(!DoesLoggerExist)
                    {
                        logger = new RealLogger();
                    }
                
                    return logger;
                }
            
                private bool DoesLoggerExist
                {
                    get { return logger != null; }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Object,System.String)">
            <summary>
            Overloaded. Verifies that a non-public property setter has been called with a specific value
            </summary>
            <param name="fake">The fake object to verify property behavior on</param>
            <param name="propertyName">The non-public property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property set was not called or if it was called with a mismatching value.
            </exception>
            <remarks>
            In order to specify the argument to verify use the proceeding method <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier.WithArgument(System.Object)"/>.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private property
            set has been called with a specific value:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled_WithSpecificArgument()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the private property LineCount has been set to 1
               Isolate.Verify.NonPublic.Property.WasCalledSetWithExactArgument(fake, "LineCount").WithArgument(1);
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public void override Write(string message)
                {
                    LineCount = lineCount + 1;
                    WriteToDisk(lineCount, message);
                }
            
                private int lineCount;
                internal int LineCount
                { get; set; }
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Type,System.String)">
            <summary>
            Overloaded. Verifies that a non-public static property setter has been called with a specific value
            </summary>
            <param name="type">The type to verify static property get behavior on</param>
            <param name="propertyName">The non-public property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property set was not called or if it was called with a mismatching value.
            </exception>
            <remarks>
            In order to specify the argument to verify use the proceeding method <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier.WithArgument(System.Object)"/>.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private static property
            set has been called with a specific value:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled_WithSpecificArgument()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // Verify the private property LoggerCount has been set to 1
               Isolate.Verify.NonPublic.Property.WasCalledSetWithExactArgument(typeof(LoggerFactory), "LoggerCount").WithArgument(1);
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                public ILogger GetLogger()
                {
                    LoggerCount++;
                    return ...;
                }
            
                private static int loggerCount = 0;
                protected static int LoggerCount
                { get; set; }
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledGet(System.Object,System.String)">
            <summary>
            Overloaded. Verifies that a non-public property get was not called regardless of parameters.
            </summary>
            <param name="fake">The fake object to verify property behavior on</param>
            <param name="propertyName">The property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property getter was called at least once.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property get was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello world!");
            
               // The logger write was called, so an internal call to the IsDiskFull property was performed - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledGet(fake, "IsDiskFull"); 
            }
            
            
            // Exceprt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                public void override Write(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
            
                    WriteToFile(fileName, message);
                }
            
                private bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledGet(System.Type,System.String)">
            <summary>
            Overloaded. Verifies that a non-public static property get was not called regardless of parameters.
            </summary>
            <param name="type">The type to verify static property behavior on</param>
            <param name="propertyName">The property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property getter was called at least once.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property get was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // We retrieved a RealLogger and an internal call to LoggerFactory.LoggerInstance was made - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledGet(typeof(LoggerFactory), "LoggerInstance"); 
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                public ILogger GetLogger()
                {
                    if(LoggerInstance == null)
                    {
                        LoggerInstance = new ...;
                    }
                    return LoggerInstance;
                }
                
                protected ILogger LoggerInstance
                {
                    get { ... }
                    set { ... }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledSet(System.Object,System.String)">
            <summary>
            Overloaded. Verifies that a non-public property set was not called regardless of parameters.
            </summary>
            <param name="fake">The fake object to verify property behavior on</param>
            <param name="propertyName">The property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property setter was called at least once.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property set was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello world!");
            
               // The logger write was called, so internal property LineCount was updated - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledSet(fake, "LineCount"); 
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public void override Write(string message)
                {
                    LineCount = lineCount + 1;
                    WriteToDisk(lineCount, message);
                }
            
                private int lineCount;
                internal int LineCount
                { get; set; }
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledSet(System.Type,System.String)">
            <summary>
            Overloaded. Verifies that a non-public static property set was not called regardless of parameters.
            </summary>
            <param name="type">The type to verify static property behavior on</param>
            <param name="propertyName">The property to verify behavior for</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the property setter was called at least once.
            </exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property set was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // We created a RealLogger and an internal property LoggerFactory.LoggerCount was updated - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledSet(typeof(LoggerFactory), "LoggerCount"); 
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                public ILogger GetLogger()
                {
                    LoggerCount++;
                    return ...;
                }
            
                private static int loggerCount = 0;
                protected static int LoggerCount
                { get; set; }
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IArguments">
            <summary>
            Returned by Isolate.Verify.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Object,System.String)"/>, this interface is used to verify
            the call was made with specific arguments 
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])">
            <summary>
            Verify the call was made with the specified arguments
            </summary>
            <param name="argument">Mandatory. The first argument to verify.</param>
            <param name="additionalArguments">Optional. Additional arguments to verify.</param>
            <remarks>
            <para>
            This method is used to complement verifying calls, using 
            Isolate.Verify.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Object,System.String)"/>, with specific argument verification.
            </para>
            <para>
            All expected call arguments must be passed to this method in order for verification to be performed.
            </para>
            </remarks>
            <exception cref="T:TypeMock.VerifyException">Thrown if the call was made with mismatching arguments</exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was called with specific arguments:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the internal call to WriteToDisk() was performed with correct arguments
               Isolate.Verify.NonPublic.WasCalled(fake, "WriteToDisk").WithArguments("Hello");
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public void override Write(string message)
                {
                    WriteToDisk(message);
                }
            
                private void WriteToDisk(string content)
                { ... }
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier">
            <summary>
            Returned by Isolate.Verify.Property.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Object,System.String)"/> and 
            Isolate.Verify.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Type,System.String)"/>, this interface is used to verify
            a property setter call was made with the correct argument
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier.WithArgument(System.Object)">
            <summary>
            Verify the property set call was made with the specified argument
            </summary>
            <param name="argument">The property set value to verify.</param>
            <remarks>
            This method is used to complement verifying property set, using 
            Isolate.Verify.NonPublic.Property.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Object,System.String)"/>, 
            with specific argument verification.
            </remarks>
            <exception cref="T:TypeMock.VerifyException">Thrown if the property set call was made with a mismatching argument</exception>
            <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private property
            set has been called with a specific value:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled_WithSpecificArgument()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the private property LineCount has been set to 1
               Isolate.Verify.NonPublic.Property.WasCalledSetWithExactArgument(fake, "LineCount").WithArgument(1);
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public override void Write(string message)
                {
                    LineCount++;
                    WriteToDisk...;
                }
            
                private int lineCount;
                internal int LineCount
                { get; set; }
                
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier">
            <summary>
            Returned by Isolate.Verify.<see cref="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Indexer"/>, this interface contains methods for verifying non
            public (private, protected and internal) index calls.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)">
            <summary>
            Verify a call has been made to a non-private index getter
            </summary>
            <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier"/> reference
            </returns>
            <param name="fake">The fake object to verify index behavior on</param>
            <remarks>
            In order to verify the index getter has been called at a specific index location, use the proceeding method 
            <see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier.WithIndex``1(``0)"/>.
            </remarks>
            <example>
            This example shows how to use Isolate.NonPublic.Indexer.WasCalledGet() in order to verify behavior on a private index setter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyIndexGetterWasCalled()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                string line = fake.GetLineAt(10);
            
                // Verify a get call to the LogFile's internal indexer was made
                Isolate.Verify.NonPublic.Indexer.WasGetCalled(fake).WithIndex(10);
            }
            
            // Excerpt from class under test
            public class LogFile
            {
                public string GetLineAt(int lineNumber)
                {
                    return this[lineNumber];
                }
                
                protected string this[int line]
                {
                    get { return ...; }
                }
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier.WithIndex``1(``0)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledSet(System.Object)">
             <summary>
             Verify a call has been made to a non-private index setter
             </summary>
             <returns>
             An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier"/> reference
             </returns>
             <param name="fake">The fake object to verify index behavior on</param>
             <remarks>
             In order to verify the index getter has been called at a specific index location and value, use the proceeding method 
             <see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)"/>.
             </remarks>
             <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasCalledSet() in 
             order to verify behavior on a private index setter:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexSetterWasCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 // set the position to write at - this will be used for internal index value
                 fake.SetPosition(10);
                 fake.Write("Hello World");
             
                 // Verify a set call to the LogFile's internal indexer was made at the correct index
                 Isolate.Verify.NonPublic.Indexer.WasSetCalled(fake).WithIndexAndValue(10, "Hello World");
             }
             
             // Excerpt from class under test
             public class LogFile
             {
                 private int currentPosition = 0;
                 public void Write(string message)
                 {
                     this[currentPosition] = message;
                 }
             
                 public void SetPosition(int value)
                 {
                     currentPosition = value;
                 }
                 
                 protected string this[int line]
                 {
                     set { WriteToFile(line, value); }
                 }
             }
             </code>
             </example>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasNotCalledGet(System.Object)">
             <summary>
             Verify a call has not been made to a non-private index getter
             </summary>
             <param name="fake">The fake object to verify index behavior on</param>
             <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasNotCalledGet() 
             in order to verify a private index getter has not been called:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexGetterWasNotCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 string line = fake.GetLineAt(10)
             
                 // The internal index was used to retrieve the log line - this verification should fail
                 Isolate.Verify.NonPublic.Indexer.WasNotCalledGet(fake);
             }
             
             
             // Excerpt from class under test
             public class LogFile
             {
                 public string GetLineAt(int lineNumber)
                 {
                     return this[lineNumber];
                 }
                 
                 protected string this[int line]
                 {
                     get { return ...; }
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasNotCalledSet(System.Object)">
             <summary>
             Verify a call has not been made to a non-private index setter
             </summary>
             <param name="fake">The fake object to verify index behavior on</param>
             <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasNotCalledSet() 
             in order to verify a private index getter has not been called:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexSetterWasNotCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 // set the position to write at - this will be used for internal index value
                 fake.SetPosition(10);
                 fake.Write("Hello World");
             
                 // The internal index was set during the Write operation so this verification will fail
                 Isolate.Verify.NonPublic.Indexer.WasNotCalledSet(fake);
             }
             
             // Excerpt from class under test
             public class LogFile
             {
                 private int currentPosition = 0;
                 public void Write(string message)
                 {
                     this[currentPosition] = message;
                 }
             
                 public void SetPosition(int value)
                 {
                     currentPosition = value;
                 }
                 
                 protected string this[int line]
                 {
                     set { WriteToFile(line, value); }
                 }
             }
             </code>
             </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier">
            <summary>
            Returned by Isolate.Verify.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)"/>, this interface is used to verify an index
            getter was called with a specific index.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier.WithIndex``1(``0)">
            <summary>
            Verify the index getter was made with the specific index location
            </summary>
            <param name="index">The index location value to verify</param>
            <typeparam name="T">The type of the index used. Can be inferred from <see cref="!:index"/></typeparam>
            <remarks>
            This method is used to complement verifying index getter calls, using 
            Isolate.Verify.NonPublic.Indexer.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)"/>, with specific index location verification.
            </remarks>
            <example>
            This example shows how to use Isolate.NonPublic.Indexer.WasCalledGet() in order to verify behavior on a private index setter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyIndexGetterWasCalled()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                string line = fake.GetLineAt(10);
            
                // Verify a get call to the LogFile's internal indexer was made
                Isolate.Verify.NonPublic.Indexer.WasGetCalled(fake).WithIndex(10);
            }
            
            // Excerpt from class under test
            public class LogFile
            {
                public string GetLineAt(int index)
                {
                    return this[index];
                }
                
                internal string this[int line]
                {
                    get { return GetFromLog(line); } 
                }
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)">
             <summary>
             Verify the index setter was called with a specific index location and setter value
             </summary>
             <param name="index">The index location value to verify</param>
             <param name="value">The setter value to verify</param>
             <typeparam name="TIndex">The type of the index used. Can be inferred from <see cref="!:index"/></typeparam>
             <typeparam name="TValue">The type of the setter value used. Can be inferred from <see cref="!:value"/></typeparam>
             <remarks>
             This method is used to complement verifying index setter calls, using 
             Isolate.Verify.NonPublic.Indexer.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledSet(System.Object)"/>, with specific 
             index location and value verification.
             </remarks>
             <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasCalledSet() in 
             order to verify behavior on a private index setter:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexSetterWasCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 // set the position to write at - this will be used for internal index value
                 fake.SetPosition(10);
                 fake.Write("Hello World");
             
                 // Verify a set call to the LogFile's internal indexer was made
                 Isolate.Verify.NonPublic.Indexer.WasSetCalled(fake).WithIndexAndValue(10, "Hello World");
             }
             
             // Excerpt from class under test
             public class LogFile
             {
                 private int currentPosition = 0;
                 public void Write(string message)
                 {
                     this[currentPosition] = message;
                 }
             
                 public void SetPosition(int value)
                 {
                     currentPosition = value;
                 }
                 
                 protected string this[int line]
                 {
                     set { WriteToFile(line, value); }
                 }
             }
             </code>
             </example>
             <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)"/>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`2">
            <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})"/> method.
            </summary>
            <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,System.Boolean})">
            <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})"/> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
            <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
            <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1"/> interface reference</returns>
            <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) => fake.AddLines(i))
                    .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`3">
            <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})"/> method.
            </summary>
            <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})">
            <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})"/> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
            <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
            <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1"/> interface reference</returns>
            <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) => fake.AddLines(i))
                    .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`4">
            <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})"/> method.
            </summary>
            <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`4.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})">
            <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})"/> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
            <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
            <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1"/> interface reference</returns>
            <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) => fake.AddLines(i))
                    .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1">
            <summary>
            Interface for specifying behavior for intercepted calls on public methods returning values. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
            </summary>
            <remarks>
            This interface allow tweaking the behavior of public base methods that has return values.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1.OnBase(System.Type)">
            <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
            <remarks>
            <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
            <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
            </remarks>
            <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Set return value only on base method
                Isolate.WhenCalled(() => fake.VirtualMethod(0)).OnBase().WillReturn(10);
            
                // Check that the correct value returned
                Assert.AreEqual(10, fake.VirtualMethod(0));
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1.OnBase">
            <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
            <remarks>
            <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
            </remarks>
            <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Set return value only on base method
                Isolate.WhenCalled(() => fake.VirtualMethod(0)).OnBase().WillReturn(10);
            
                // Check that the correct value returned
                Assert.AreEqual(10, fake.VirtualMethod(0));
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidRootMethodHandler`1">
            <summary>
            Interface for specifying behavior for intercepted calls on public methods returning values. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
            </summary>
            <remarks>
            This interface allow tweaking the behavior of public methods that has return values.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidRootMethodHandler`1.ReturnRecursiveFake">
            <summary>
            Specify that the intercepted method will return a recursive fake.
            The real implementation will not be executed.
            </summary>
            <remarks>
            <para>
            ReturnRecursiveFake() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/>. It
            is similar to using the <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes"/> behavior setting when creating 
            fake objects with <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>, but applies only to a single method.
            </para>
            Use ReturnRecursiveFake() on a method to fake out calls to the method and any call chains 
            beginning with it. When ReturnRecursiveFake() is called on a method returning an object, 
            a fake object will be returned. That fake object in turn will return fake values for any 
            method calls. 
            ReturnRecursiveFake() on a method returning a value type will set the method to return 
            the default value of that type. 
            
            When ReturnRecursiveFake() is used on methods whose returned value is a collection
            in mscorlib (only collections that implement IEnumerable and have default constructor)
            then a new initialized collection is returned.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)"/>
            <seealso cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes"/>
            <example>
            This example shows using ReturnRecursiveFake() to fake out a call chain
            <code>
            [TestMethod]
            [Isolated]
            public void ReturnRecursiveFake_ChainedCallsAreFake()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // exclude one method from the default behavior and return a recursive fake from it
                Isolate.WhenCalled(() => fake.Storage).ReturnRecursiveFake();
            
                // subsequent calls to the method will not return null values
                Assert.IsNotNull(fake.Storage);
                Assert.IsNotNull(fake.Storage.FileSystem);
                // methods returning a value type will return the default value for the type
                Assert.AreEqual(0, fake.Storage.FreeSpaceInBytes);
            }
            </code>
            </example>
            <returns>The fake object that will be returned. WhenCalled should be used on this object to setup specific behavior.
            </returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidRootMethodHandler`1.WithExactArguments">
            <summary>
            Specifies that the behavior will only be set on method calls with the exact arguments.
            </summary>
            <remarks>
            <para>
            WithExactArguments() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/>. 
            </para>
            </remarks>
            <example>
            This example shows how to use WithExactArguments() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void WithExactArguments_DifferentArgsReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // Set return value according to exact arguments
                Isolate.WhenCalled(() => fake.IntCallWithArg(0)).WithExactArguments().WillReturn(10);
                Isolate.WhenCalled(() => fake.IntCallWithArg(1)).WithExactArguments().WillReturn(20);
            
                // Check that the correct value returned
                Assert.AreEqual(10, fake.IntCallWithArg(0));
                Assert.AreEqual(20, fake.IntCallWithArg(1));
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IMethodBehavior">
            <summary>
            Interface for specifying behavior for a method call. The interface is extended by <see cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/> and <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1"/>.
            </summary>
            <remarks>
            This interface allow tweaking the behavior of any method by calling its original implementation or throwing an exception from it.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IMethodBehavior.CallOriginal">
            <summary>
            Specify that an intercepted call will try to execute the real logic of the intercepted instance.
            </summary>
            <remarks>
            This interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
            <para>
            Before using this directive make sure that the intercepted method has a real implementation that can be executed.
            </para>
            </remarks>
            <example>
            This test shows faking an object to return null values, and overriding one of its methods to call its original
            implementation:
            <code>
            [TestMethod]
            [Isolated]
            public void CallOriginalOnFakeInstance()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls);
                
                // Override the Increment() method to call its original implementation
                Isolate.WhenCalled(() => fake.Increment()).CallOriginal();
            
                // Make sure Count is reset
                fake.Count = 0;
            
                // This call now redirects to its original implementation - the count should increment
                fake.Increment();
                Assert.AreEqual(1, fake.Count);
            
                // even though we called the original implementation, we can still verify the call happened
                Isolate.Verify.WasCalledWithAnyArguments(() => fake.Increment());
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IMethodBehavior.WillThrow(System.Exception)">
            <summary>
            Specify that an intercepted call will throw the given exception.
            </summary>
            <remarks>
            This interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
            </remarks>
            <param name="ex"> The exception to throw</param>
            <example>
            This test shows faking an object, and overriding one of its methods to throw an exception:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfMemoryException))]
            public void WillThrowOnFakeInstance()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Override the Write() method to throw an exception
                Isolate.WhenCalled(() => fake.Write("")).WillThrow(new OutOfMemoryException());
            
                // This call will now throw an exception when called - this is verified by the
                // [ExpectedException] decorator
                fake.Write("Hello");
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler">
            <summary>
            Interface for specifying behavior for intercepted calls on public void methods. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
            </summary>
            <remarks>
            This interface allow tweaking the behavior of public base methods that has return values.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler.OnBase(System.Type)">
            <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
            <remarks>
            <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
            <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
            </remarks>
            <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Ignore only base method
                Isolate.WhenCalled(() => fake.VirtualMethod(0)).OnBase(typeof(BaseLogger)).IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler.OnBase">
            <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
            <remarks>
            <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
            </remarks>
            <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Ignore only base method
                Isolate.WhenCalled(() => fake.VirtualMethod(0)).OnBase().IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidWithExactActionHandler">
            <summary>
            Interface for specifying behavior for intercepted calls on public void methods. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
            </summary>
            <remarks>
            This interface allow tweaking the behavior of public base methods that has return values.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicVoidWithExactActionHandler.WithExactArguments">
            <summary>
            Specifies that the behavior will only be set on method calls with the exact arguments.
            </summary>
            <remarks>
            <para>
            WithExactArguments() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/>. 
            </para>
            </remarks>
            <example>
            This example shows how to use WithExactArguments() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void WithExactArguments_DifferentArgsReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // Set return value according to exact arguments
                Isolate.WhenCalled(() => fake.VoidCallWithArg(0)).WithExactArguments().IgnoreCall();
                Isolate.WhenCalled(() => fake.VoidCallWithArg(1)).WithExactArguments().CallOriginal();
                Isolate.WhenCalled(() => fake.VoidCallWithArg(2)).WithExactArguments().WillThrow(new Exception(""));
            
                // Check that the correct value returned
                fake.VoidCallWithArg(0); // This call will be ignored
                fake.VoidCallWithArg(1); // This call will call the real method
                fake.VoidCallWithArg(2); // This call will throw an exception
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1">
            <summary>
            Interface for specifying behavior for intercepted calls on methods returning values. 
            The interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/>.
            </summary>
            <remarks>
            This interface allow tweaking the behavior of methods that has return values.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1.WillReturn(`0)">
            <summary>
            Specify that the intercepted method will return the given value.
            The real implementation will not be executed.
            </summary>
            <param name="value">The fake value to return when the call is intercepted</param>
            <example>
            This example shows using WillReturn() to change the return value for a property call:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_ChangeMethodReturnValue()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value for Count property
                Isolate.WhenCalled(() => fake.Count).WillReturn(10);
            
                // fake.Count will return the assigned value
                Assert.AreEqual(10, fake.Count);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1.DoInstead(System.Func{TypeMock.MethodCallContext,`0})">
             <summary>
             Run a custom function instead of the methods in the WhenCalled block.
             </summary>
             <param name="function">The function that will run instead of the faked method</param>
             <example>
             This example shows using DoInstead() to run custom code instead of a function:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_DoInstead()
             {
                 var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
                 // Use DoInstead to replace the method called with custom function
                 Isolate.WhenCalled(() => fake.IntCallWithArgs(0))
                     .DoInstead((callContext) =>
                         {
                             // We can set field on the instance that called the method
                             ((RealLogger)callContext.Instance).count = (int)callContext.ParametersDefaultValuesGenerator[0];
            
                             // Change the returned value  
                             return 100;
                         });
            
                 int value = fake.IntCallWithArgs(10);
             
                 // Verify
                 Assert.AreEqual(100, value);
                 Assert.AreEqual(10, fake.count);
             </code>
             </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler">
            <summary>
            Interface for specifying behavior for a void returning intercepted calls. The interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
            </summary>
            <remarks>
            This interface allow tweaking the behavior of methods which return void.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler.IgnoreCall">
             <summary>
             Specify that an intercepted call should be ignored without executing any logic.
             </summary>
             <remarks>
             This interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> method.
             </remarks>
             <example>
             This example shows using IgnoreCall() to stub out a call to a method:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Increment call will be ignored (stubbed)
                 Isolate.WhenCalled(() => fake.Increment()).IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler.DoInstead(System.Action{TypeMock.MethodCallContext})">
            <summary>
            Run a custom action instead of the methods in the WhenCalled block.
            </summary>
            <param name="action">The action that will run instead of the faked method</param>
            <example>
            This example shows using DoInstead() to run custom code instead of a function:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_DoInstead()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
                // Use DoInstead to replace the called method with custom action
                Isolate.WhenCalled(() => fake.CallWithArguments("", 0, 0.0))
                    .DoInstead((callContext) =>
                            {
                                // Change the value of a field in the object that called the method
                                ((RealLogger)callContext.Instance).count = (int)callContext.ParametersDefaultValuesGenerator[1];
                            });
                
                // Call the method
                fake.CallWithArguments(100);
            
                // Verify the field's value
                Assert.AreEqual(100, fake.count);
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1">
            <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/> method.
            </summary>
            <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1.AndArgumentsMatch(System.Func{`0,System.Boolean})">
             <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Func{``0})"/> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
             <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler"/> interface reference</returns>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2">
            <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Action{``0,``1})"/> method.
            </summary>
            <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Action{``0,``1})"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})">
             <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})"/> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
             <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler"/> interface reference</returns>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3">
            <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Action{``0,``1,``2})"/> method.
            </summary>
            <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Action{``0,``1,``2})"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})">
             <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})"/> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
             <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
             <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler"/> interface reference</returns>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.ISwapper">
            <summary>
            Interface used for swapping between object method calls and collection values.
            </summary>
            <remarks>
            This interface is returned by the Isolate.<see cref="P:TypeMock.ArrangeActAssert.Isolate.Swap"/> property.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TypeMock.ArrangeActAssert.Fluent.ISwapper.NextInstance``1" -->
        <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.AllInstances``1">
             <summary>
             Return a swapping object, in order to swap all past and future instance of type T with an existing fake object.
             Use this method to set the same behavior on all instances of the same type.
             </summary>
             <returns>An <c>ISwapperBehavior</c> interface refernce.</returns>
             <remarks>
             Because of the nature of fluent interface, you need to use AllInstances with its
             proceeding methods <see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)"/> or <see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.ConstructorWillThrow(System.Exception)"/>
             </remarks>
             <example>
             This example shows using AllInstances in order to set the same behavior on two instances:
             <code>
             [TestMethod, Isolated]
             public void SwapAllInstances_FakeFutureAndPastInstances_AllInstancesAreFaked()
             {
                 var logger1 = new RealLogger();
             
                 var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 Isolate.WhenCalled(() => fake.ReturnFive()).WillReturn(50);
            
                 // set behavior on all future and past instances of RealLogger
                 Isolate.Swap.AllInstances&lt;RealLogger&gt;().With(fake);
             
                 var logger2 = new RealLogger();
                 
                 // Verify behavior of past instance is faked
                 Assert.AreEqual(50, logger1.ReturnFive());
                 // Verify behavior of future instance is faked
                 Assert.AreEqual(50, logger2.ReturnFive());
             }
             </code>
             </example>
             <note>
             The constructor behavior of the next instances will follow the constructor behavior of the swapped instance.
             If it is a real object it will be called, if it is a fake it will follow the fakes behavior
             </note>
             <typeparam name="T">Type of instances to swap.</typeparam>        
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)">
            <summary>
            Enables swapping one object's implementation with another. Followed by the completing statement 
            <see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)"/>.
            </summary>
            <param name="toSwap">The object to swap implementation for</param>
            <returns>An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper"/> interface reference. </returns>
            <remarks>
            When a method is called on the swapped object, it is replaced with a corresponding implementation (a method
            with the same signature) on the swapping object. This means that the swapped object will start behaving like
            the object it was swapped with for all methods they have in common.
            </remarks>
            <example>
            This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)"/>.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)"/> 
            in order to redirect calls from an object to a stand-in object:
            <code>
            [TestMethod]
            [Isolated]
            public void SwapCallsOnObject_CallsRedirectedToTargetObject()
            {
                // Create the object under test
                RealLogger logger = new RealLogger();
                // Create the object calls will be redirected to
                TestLogger swapped = new TestLogger();
            
                // Redirect any calls from the object under test to the swapping target
                Isolate.Swap.CallsOn(logger).WithCallsTo(swapped);
            
                // logger.Write() is redirected to TestLogger.Write() which writes to console instead of disk
                logger.Write("Hello World");
            
                // We can still verify the call to logger.Write() happened
                Isolate.Verify.WasCalledWithAnyArguments(() => logger.Write(""));
            }
            
            // excerpt code for the class under test:
            public class RealLogger
            {
                string logFilePath = ...;
                public void Write(string toWrite)
                {
                    logFile.WriteAllText(logFilePath, toWrite);
                }
            }
            
            // excerpt code for the replacement class:
            public class TestLogger
            {
                public void Write(string toWrite)
                {
                    Console.WriteLine("RealLogger.Write() was called with {0}", toWrite);
                }
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)"/>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler">
            <summary>
            Returned by <seealso cref="P:TypeMock.ArrangeActAssert.Isolate.Verify"/>, this interface contains methods for verifying the method calls and checking their arguments.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler.OnBase(System.Type)">
            <summary>
            Overloaded. Verifies that the method in a base class was called. The baseType must be in the last calls heiarchy.
            </summary>
            <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
            <exception cref="!:TypemockException">
            Thrown if the base type can not be found.
            </exception>
            <remarks>
            The verify uses the following statements to configure what to verify
            </remarks>
            <example>
            This example shows how to use Isolate.Verify.OnBase:
            <code>
            [TestMethod]
            [Isolated]
            public void OnBaseExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;DeviredLogger&gt;(Members.CallOriginal);
            
               string entry = fake.VirtualMethod();
            
               Isolate.Verify.Base(typeof(BaseLogger)).WasCalledWithAnyArguments(() => fake.VirtualMethod());
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler.OnBase">
            <summary>
            Overloaded. Verifies that the method in the base class was called. The baseType must be in the last calls heiarchy.
            </summary>
            <exception cref="!:TypemockException">
            Thrown if the base type can not be found.
            </exception>
            <remarks>
            The verify uses the following statements to configure what to verify
            </remarks>
            <example>
            This example shows how to use Isolate.Verify.OnBase:
            <code>
            [TestMethod]
            [Isolated]
            public void OnBaseExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;DeviredLogger&gt;(Members.CallOriginal);
            
               string entry = fake.VirtualMethod();
            
               Isolate.Verify.Base().WasCalledWithAnyArguments(() => fake.VirtualMethod());
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler.GetInstancesOf``1(``0)">
            <summary>
            Returns faked objects that where created using Isolate.<see cref="!:Fake.NextInstance"/> and Isolate.<see cref="!:Fake.AllInstances"/>.
            </summary>
            <param name="fake">a fake instance</param>
            <returns>An array of instances that are controlled by the fake</returns>
            <exception cref="!:TypemockException">
            Thrown if fake has no instances that where instantiated.
            </exception>
            <remarks>
            Do not use <see cref="P:TypeMock.ArrangeActAssert.Isolate.Verify"/> on the returned instances, use the fake instance instead.
            Instances that have been GC'ed will not apear.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify.GetInstancesOf in order to grab a future instance.
            This API can be used to check fields on the created instances
            and to pass it as an argument to <see cref="!:Verify.WasCalledWithExactArguments"/>.
            <code>
            [TestMethod,Isolated]
            public void FakeFutureInstance_GetInstance()
            {
               var handle = Isolate.Fake.NextInstance&lt;RealLogger&gt;();
               var item = Factory.CreateRealLogger();
            
               Assert.AreSame(item, Isolate.Verify.GetInstancesOf(handle)[0]);
            }
            [TestMethod,Isolated]
            public void Fake_MultipleFutureInstances_CheckFutureFields()
            {
               var handle = Isolate.Fake.AllInstances&lt;Dependency&gt;();
               ClassUnderTest.AddCheckingTwoInternalDependencies(1, 2);
            
               var instance2 = Isolate.Verify.GetInstancesOf(fake)[1];
            
               Assert.AreEqual(2, instance2.field);
            }
            [TestMethod]
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler">
            <summary>
            Returned by <seealso cref="P:TypeMock.ArrangeActAssert.Isolate.Verify"/>, this interface contains methods for verifying the method calls and checking their arguments.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.GetTimesCalled``1(System.Func{``0})">
            <summary>
            Overloaded. Returns the number of times a method was called.
            </summary>
            <param name="func">A method in the form of a Lambda Expression that we want to count the calls on.</param>
            <exception cref="!:TypemockException">
            Thrown if there was no behavior set on the object before.
            </exception>
            <remarks>
            The count is regardless of arguments, and can work on both instance and static methods. It works also on properties and indexers.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify.GetTimesCalled in order to count the calls:
            <code>
            [TestMethod]
            [Isolated]
            public void GetTimesCalledExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               string entry = fake.GetEntry();
            
               int count = Isolate.Verify.GetTimesCalled(() => fake.GetEntry());
               
               Assert.AreEqual(1, count);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.GetTimesCalled(System.Action)">
            <summary>
            Overloaded. Returns the number of times a method was called.
            </summary>
            <param name="action">A coid method in the form of a Lambda Expression that we want to count the calls on.</param>
            <exception cref="!:TypemockException">
            Thrown if there was no behavior set on the object before.
            </exception>
            <remarks>
            The count is regardless of arguments, and can work on both instance and static methods. It works also on properties and indexers.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify.GetTimesCalled in order to count the calls:
            <code>
            [TestMethod]
            [Isolated]
            public void GetTimesCalledExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               int count = Isolate.Verify.GetTimesCalled(() => fake.Write("Hello"));
               
               Assert.AreEqual(1, count);
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithAnyArguments(System.Action)">
            <summary>
            Overloaded. Verifies that a method was called, without checking its arguments.
            </summary>
            <param name="action">A void method in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called.
            </exception>
            <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            When arguments are specified, they are ignored in the verification.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               // We did not check the call for argument matching so this verification should pass
               Isolate.Verify.WasCalledWithAnyArguments(() => fake.Write("Goodbye"));
            }
            </code>
            </example>
            <seealso cref="M:TypeMock.ArrangeActAssert.Verifier.WasCalledWithExactArguments(System.Action)"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithAnyArguments``1(System.Func{``0})">
            <summary>
            Overloaded. Verifies that a method was called, without checking its arguments.
            </summary>
            <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called.
            </exception>
            <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            When arguments are specified, they are ignored in the verification.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls);
            
               int x = fake.GetCount();
            
               Isolate.Verify.WasCalledWithAnyArguments(() => fake.GetCount());
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithExactArguments(System.Action)">
            <summary>
            Overloaded. Verifies that a method was called, and checking its arguments.
            </summary>
            <param name="action">A void method in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called with the specified arguments.
            </exception>
            <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify in order to check a method was called 
            with a specific set of arguments:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled_WithExactArguments()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               // As we're verifying the call was made with exact arguments, this verification should fail
               Isolate.Verify.WasCalledWithExactArguments(() => fake.Write("Goodbye")); 
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithExactArguments``1(System.Func{``0})">
            <summary>
            Overloaded. Verifies that a method was called, and checking its arguments.
            </summary>
            <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called with the specified arguments.
            </exception>
            <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify in order to check a method was called 
            with a specific set of arguments:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled_WithExactArguments()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               // As we're verifying the call was made with exact arguments, this verification should fail
               Isolate.Verify.WasCalledWithExactArguments(() => fake.Write("Goodbye")); 
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalled(System.Action)">
            <summary>
            Overloaded. Verifies that a method was not called regardless of parameters.
            </summary>
            <param name="action">A void method in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was called at least once.
            </exception>
            <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
            <example>
            This example shows how to use Isolate.Verify in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment();
            
               // This verification should fail
               Isolate.Verify.WasNotCalled(() => fake.Increment()); 
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalled``1(System.Func{``0})">
            <summary>
            Overloaded. Verifies that a method was not called regardless of parameters.
            </summary>
            <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was called at least once.
            </exception>
            <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>        
            <example>
            This example shows how to use Isolate.Verify in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment();
            
               // This verification should fail
               Isolate.Verify.WasNotCalled(() => fake.Increment()); 
            }
            </code>
            </example>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.NonPublic">
            <summary>
            Provides an entry point to verify non-public (private, protected, internal) members
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments``1(System.Func{``0})">
            <summary>
            Overloaded. Verifies that a method was called, and checking its arguments using custom verifier.
            </summary>        
            <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, was not called with arguments matching the custom verifier.
            </exception>
            <remarks>
            Calls to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments``1(System.Func{``0})">WasCalledWithArguments</see> must be followed with call to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">Matching()</see> method.
            </remarks>
            <example>
            The following example verifies a method was called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1);
            
                Isolate.Verify.WasCalledWithArguments(() => fake.Log(0)).Matching(args => (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1, "str");
            
                Isolate.Verify.WasCalledWithArguments(() => fake.Log(0, null))
                    .Matching(args => ((int) args[0] > 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments(System.Action)">
            <summary>
            Overloaded. Verifies that a method was called, and checking its arguments using custom verifier.
            </summary>        
            <param name="action">A method in the form of a Lambda Expression that we want to verify if was called.</param>
            <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, was not called with arguments matching the custom verifier.
            </exception>
            <remarks>
            Calls to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments``1(System.Func{``0})">WasCalledWithArguments</see> must be followed with call to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">Matching()</see> method.
            </remarks>
            <example>
            The following example verifies a method was called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1);
            
                Isolate.Verify.WasCalledWithArguments(() => fake.Log(0)).Matching(args => (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1, "str");
            
                Isolate.Verify.WasCalledWithArguments(() => fake.Log(0, null))
                    .Matching(args => ((int) args[0] > 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Args">
            <summary>
            Args is a helper class for passing arguments into a non-public invoked methods
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Args.Ref``1(``0)">
            <summary>
            Creates a wrapper for passing an argument by reference.
            </summary>
            <param name="argParam">An initialized argument</param>
            <typeparam name="T">The type of the passed argument</typeparam>
            <returns>A wrapper that can be passed to Isolate.Invoke.Method</returns>
            <remarks>
            Ref helps create a wrapper for passing an argument by reference as part of the params argument list of Invoke.Method. 
            After the method invocation, it can be checked to the updated value.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Args.Out``1">
            <summary>
            Creates a wrapper for passing an Out argument by reference
            </summary>
            <typeparam name="T">The type of the passed argument</typeparam>
            <returns>A wrapper that can be passed to Isolate.Invoke.Method</returns>
            <remarks>
            Out helps create a wrapper for passing an Out argument as part of the params argument list of Invoke.Method. 
            Since an Out value is created inside the called method, there's no argument to pass. 
            After the method invocation, the wrapper can be checked for the updated value.
            </remarks>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Args.Null``1">
            <summary>
            Creates a wrapper for passing null - nullable arguments.
            </summary>
            <typeparam name="T">The type of the argument</typeparam>
            <returns>
            A wrapper that can be passed to Isolate.Invoke.Method
            </returns>
            <remarks>
            Null helps create a wrapper for passing a null initialized argument for a nullable type. While it 
            can be stored, it is better to use as an inline argument in the params section of Inovke.Method.
            </remarks>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Suggest.PotentialBugAttribute">
            <summary>
             Used to mark a test as a potential bug. 
             SafetyNet marks tests with this attribute automatically
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.PotentialBugAttribute.#ctor(System.String)">
            <summary>
            Mark test as a potential bug
            </summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute">
            <summary>
             Used to mark a test fixture as auto-generated. 
             Typemock Smart Runner uses this attribute to determine if tests should run in a restricted environment.
            </summary>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute.Sandbox">
            <summary>
            Should generated test be run in a sandboxed environment. Default is true.
            </summary>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute.UnderTest">
            <summary>
            The under test type for which the tests were generated for.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute.#ctor(System.Type)">
            <summary>
            Mark test class as auto-generated. When sandboxed (default option), tests will run in a restricted environment.
            </summary>
            <param name="underTest">The type for which the tests were generated for.</param>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Suggest.SuggestBehaviorAttribute">
            <summary> Used to support backward compatability to sequencing. This attribute cant be inherited.</summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Suggest.TestUtil">
            <summary>
            Utility Class for test generated by Typemock SafetyNet
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.CallStaticCtor(System.Type)">
            <summary>
            Reset a type by calling its static constructor and resetting all of the static fields.
            </summary>
            <param name="type">The type to reset</param>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.CallStaticCtor(System.Type,System.String)">
            <summary>
            Reset a private type by calling its static constructor and resetting all of the static fields.
            </summary>
            <param name="publicTypeToGetAssembly">Any public type in the assembly of the private type</param>
            <param name="privateTypeName">Name of private type to reset</param>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ResetAllStatics">
            <summary>
            Enables and resets all statics fields by rerunning static constructors.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ExcludeResetStaticsOfType(System.String)">
            <summary>
            Specify types to not reset when using ResetAllStatics
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.SafeguardModuleInitializer">
            <summary>
            Support faking of Module initializer
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.AssertRunningInSandbox">
            <summary>
            Assert that we are running in a sandboxed environment to make sure that we don't call API's that can ruin the system. Directory.Delete for example
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ElementIsType``1(System.Collections.IEnumerable,System.Int32)">
            <summary>
            Helper method to check if the n'th item of a collections is of type T, used in suggested unit tests
            </summary>
            <typeparam name="T">Type of item</typeparam>
            <param name="collection">Collection to find item</param>
            <param name="index">Index of item to find</param>
            <returns>True if item is of correect type</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.GetElementAt``1(System.Collections.IEnumerable,System.Int32)">
            <summary>
            Helper method to get the n'th item of a collections as type T, used in suggested unit tests
            </summary>
            <typeparam name="T">Type of item</typeparam>
            <param name="collection">Collection to return item</param>
            <param name="index">Index of item to return</param>
            <returns>Item as T</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ElementsCount(System.Collections.IEnumerable)">
            <summary>
            Helper method to count the elements in a collections, used in suggested unit tests
            </summary>
            <param name="collection">Collection to count</param>
            <returns>Number of elements</returns>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Suggest.ActualCoverage">
            <summary>
            Used in test generated by Typemock SafetyNet.
            This class will make sure that we get coverage for the method under test and not the setup methods.
            </summary>
            <example>
            <code>
            var underTest = new UnderTest(5);
            int result;
            using (new ActualCoverage())
            {
               result = underTest.MethodUnderTest(8);
            }
            </code>
            Asset.IsEqual(12, result);
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.ActualCoverage.#ctor">
            <summary>
            When called Typemock Smart Runner will start collecting actual coverage
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Suggest.ActualCoverage.Dispose">
            <summary>
            When called Typemock Smart Runner will stop collecting actual coverage
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.RecorderBase.ChangeLastCallToBase(System.Type)">
            <summary>
            Call this before InvokeAndRecord to change last to base.
            </summary>
            <param name="baseType"></param>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Members">
            <summary>
            A behavior setting on how the fake object is created.
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.Members.MustSpecifyReturnValues">
            <summary>
            All void calls are ignored. Unless using WhenCalled on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException"/>.
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.Members.CallOriginal">
            <summary>
            All methods are called. Using WhenCalled allow to change this behavior.
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.Members.ReturnNulls">
            <summary>
            All void calls are ignored. Unless using WhenCalled on methods that return values and properties, they will return null values (or zero for value types).
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes">
            <summary>
            Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.Members.MustBeSpecified">
            <summary>
            All method behaviors must be define or calling them will throw a <see cref="T:TypeMock.TypeMockException"/>.
            </summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.ConstructorWillBe">
            <summary>
            A behavior setting on how the fake object is created.
            </summary>
            <remarks>
            When not using the ConstructorWillBe enum the default behavior for constructor is using the following rules:
             * When using Members.CallOriginal - The original constructor is called.
             * When using all other Members enums the constructor is not called.
            </remarks>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored">
            <summary>
            Don't execute constructor when creating a fake object
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Called">
            <summary>
            Run constructor when creating a fake object
            </summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.BaseConstructorWillBe">
            <summary>
            A behavior setting on how the base object's constructor behaves
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.BaseConstructorWillBe.Ignored">
            <summary>
            Don't execute base constructor when creating a fake object.
            </summary>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type,System.Object[])"/>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.Isolate">
            <summary>
            This is the entry point to all AAA APIs. 
            Use it to fake, swap, set method behavior and verify calls.
            The Isolate APIs use fluent interfaces, thus 
            </summary>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Isolate.Swap">
             <summary>
             A read-only property, used to swap objects and behaviors
             </summary>
             <returns>
             An <see cref="T:TypeMock.ArrangeActAssert.Fluent.ISwapper"/> interface reference.
             </returns>
             <remarks>
             Because of the nature of fluent interface, you need to use Swap with one of its proceeding methods - 
             see <see cref="T:TypeMock.ArrangeActAssert.Fluent.ISwapper"/> for details.
             </remarks>
             <example>
             This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.NextInstance``1"/>.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)"/> in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void SwapAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 Isolate.Swap.NextInstance&lt;RealLogger&gt;().With(fake);
            
                 Isolate.WhenCalled(() => fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code>
             This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)"/>.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)"/> in order to 
             redirect calls from an object to a stand-in object:
             <code>
             [TestMethod]
             [Isolated]
             public void SwapCallsOnObject_CallsRedirectedToTargetObject()
             {
                 // Create the object under test
                 RealLogger logger = new RealLogger();
                 // Create the object calls will be redirected to
                 TestLogger swapped = new TestLogger();
             
                 // Redirect any calls from the object under test to the swapping target
                 Isolate.Swap.CallsOn(logger).WithCallsTo(swapped);
             
                 // logger.Write() is redirected to TestLogger.Write() which writes to console instead of disk
                 logger.Write("Hello World");
             
                 // We can still verify the call to logger.Write() happened
                 Isolate.Verify.WasCalledWithAnyArguments(() => logger.Write(""));
             }
             
             // excerpt code for the class under test:
             public class RealLogger
             {
                 string logFilePath = ...;
                 public void Write(string toWrite)
                 {
                     logFile.WriteAllText(logFilePath, toWrite);
                 }
             }
             
             // excerpt code for the replacement class:
             public class TestLogger
             {
                 public void Write(string toWrite)
                 {
                     Console.WriteLine("RealLogger.Write() was called with {0}", toWrite);
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Isolate.Fake">
             <summary>
             A read-only property, used to fake a new object.
             </summary>
             <returns>
             An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IFaker"/> interface reference.
             </returns>
             <remarks>
             Because of the nature of fluent interface, you need to use Fake with its proceeding methods - 
             see <see cref="T:TypeMock.ArrangeActAssert.Fluent.IFaker"/> for details.
             </remarks>
             <example>
             This example shows how to use Fake in order to fake a RealLogger instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Increment call will be ignored (stubbed)
                 Isolate.WhenCalled(() => fake.Increment()).IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IFaker"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.GetFake``1(System.Object)">
            <summary>
            Get a fake that was automatically created by Isolate.Fake.Dependencies()
            </summary>
            <typeparam name="T">The Type of the requested dependency</typeparam>
            <param name="instance">An instance that was created with Isolate.Fake.Dependencies()</param>
            <returns>A fake instance</returns>
            <exception cref="T:TypeMock.TypeMockException">Exception is thrown if fake not found, T is a value-type or a string, or instance is null.</exception>
            <remarks>
            To create an instance, where all the dependencies are fake, use Isolate.Fake.Dependencies.
            To change a behavior of these fakes, use Isolate.GetFake to grab the fake, and then change bahavior like any other fake.
            <example>
            Here is an example how to use control a dependency fake of a ClassUnderTest type:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAllDependancies()
            {
                var real = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;();
                var fake = Isolate.GetFake&lt;Dependency&gt;(real);
                Isolate.WhenCalled(()=>fake.GetCustomerId()).WillReturn(100);
                
                real.Log("Test");
                Assert.AreEqual(1, real.Count);
            }
            </code>
            </example>
            </remarks>
            <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Dependencies``1(System.Object[])"/>
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Isolate.NonPublic">
             <summary>
             A read-only property, used to fake non public members
             </summary>
             <returns>
             An IIsolateNonPublic reference
             </returns>
             <remarks>
             Because of the nature of fluent interface, you need to use NonPublic with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic"/>
             <para>
             When handling non public (private, protected, internal) class members all access to method names is string-based.
             </para>
             </remarks>
             <example>
             This example shows how to use NonPublic in order to set behavior on a private method:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Avoid performing actual write to disk by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled(fake, "WriteToDisk").IgnoreCall();
             
                 // This call is faked - count should not increment
                 fake.Log("Hello World");
            
                 Assert.AreEqual(1, fake.LineCount);
                 // Verify the private call was actually made
                 Isolate.Verify.NonPublic.WasCalled(fake, "WriteToDisk").WithArguments("Hello World");
             }
             </code>
             </example>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Isolate.Verify">
            <summary>
            Return a verifying object that can verify calls were made or not, and check if their arguments were sent correctly.
            </summary>
            <returns>An ICallVerifier interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, you need to use Verify with one of its proceeding methods: 
            <see cref="M:TypeMock.ArrangeActAssert.Verifier.WasCalledWithAnyArguments(System.Action)"/>, <see cref="M:TypeMock.ArrangeActAssert.Verifier.WasCalledWithExactArguments(System.Action)"/>, <see cref="M:TypeMock.ArrangeActAssert.Verifier.WasNotCalled(System.Action)"/>
            and <see cref="!:IVerifyHandler.NonPublic"/> 
            </remarks>
            <example>
            This example shows how to use Verify in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyStubWasCalled_FailWhenNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment();
            
               Isolate.Verify.WasCalledWithAnyArguments(() => fake.Increment());
            }
            </code>
            </example>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.Isolate.Invoke">
            <summary>
            A read-only property, used to invoke object members.
            </summary>
            <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IInvoker"/> interface reference.
            </returns>
            <remarks>
            The <see cref="T:TypeMock.ArrangeActAssert.Fluent.IInvoker">Invoker</see> enables code to fire events of objects.
            </remarks>
            <example>
            The following test fires an event and verifies that registered subscriber was notified.
            <code>
            [TestMethod]
            [Isolated]
            public void FireEvent_SubscribersWereNotified()
            {
                bool wasCalled = false;
            
                var logger = new RealLogger();
                logger.Initialized += (sender, args) => wasCalled = true;
            
                Isolate.Invoke.EventWithDefaultArguments(() => logger.Initialized += null);
            
                Assert.IsTrue(wasCalled);
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IInvoker"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)">
             <summary>
             Accepts a method in the form of a Lambda expression, to set a specific behavior on it.
             </summary>
             <param name="action">An Action in a form of a Lambda expression (with no parameters) that expresses the method we want to set a behavior on.</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a call:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Increment call will be ignored (stubbed)
                 Isolate.WhenCalled(() => fake.Increment()).IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1.AndArgumentsMatch(System.Func{`0,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Action{``0,``1})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Action{``0,``1,``2})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Action{``0,``1,``2,``3})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`4"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(TypeMock.ArrangeActAssert.ExpandDelegates.Action{``0,``1,``2,``3,``4})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`5"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(TypeMock.ArrangeActAssert.ExpandDelegates.Action{``0,``1,``2,``3,``4,``5})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`6"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(TypeMock.ArrangeActAssert.ExpandDelegates.Action{``0,``1,``2,``3,``4,``5,``6})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`7"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(TypeMock.ArrangeActAssert.ExpandDelegates.Action{``0,``1,``2,``3,``4,``5,``6,``7})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`8"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(TypeMock.ArrangeActAssert.ExpandDelegates.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`9"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(TypeMock.ArrangeActAssert.ExpandDelegates.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
             <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
             <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
             to define custom arguments matching</param>
             <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
             <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
             <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) => fake.Increment(i))
                     .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code>
             </example>
             <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`10"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Func{``0})">
            <summary>
            Accepts a method in the form of a Lambda expression, to set a specific behavior on it.
            </summary>
            
            <param name="func">A function in the form of a Lambda Expression (with no parameters) that expresses the method we want to set a behavior on.</param>
            <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
            <example>
            Here is an example how to use WhenCalled in order to return a value:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of IntCall()
                Isolate.WhenCalled(() => fake.IntCall()).WillReturn(10);
            
                Assert.AreEqual(10, fake.IntCall());
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})">
            <summary>
            Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
            The expression's parameters are used to define custom argument matching.
            </summary>
            <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
            The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1.AndArgumentsMatch(System.Func{`0,System.Boolean})"/> method
            to define custom arguments matching</param>
            <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
            <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) => fake.AddLines(i))
                    .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`2"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})">
            <summary>
            Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
            The expression's parameters are used to define custom argument matching.
            </summary>
            <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
            The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})"/> method
            to define custom arguments matching</param>
            <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
            <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) => fake.AddLines(i))
                    .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`3"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
            The expression's parameters are used to define custom argument matching.
            </summary>
            <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
            The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})"/> method
            to define custom arguments matching</param>
            <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3"/> interface reference.</returns>
            <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
            <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) => fake.AddLines(i))
                    .AndArgumentsMatch(i => i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code>
            </example>
            <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`4"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Isolate.CleanUp">
            <summary>
            CleanUp should be called at the end of a test. It can be substituted with the <see cref="T:TypeMock.ArrangeActAssert.IsolatedAttribute"/>.
            </summary>
            <example>
            Here is an example how to use CleanUp. The following test uses CleanUp:
            <code>
            [TestMethod]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Increment call will be ignored (stubbed)
                Isolate.WhenCalled(() => fake.IntCall()).WillReturn(10);
            
                Assert.AreEqual(10, fake.IntCall());
                Isolate.CleanUp();
            }
            </code>
            
            The following test uses IsolatedAttribute and similar in functionality: 
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Increment call will be ignored (stubbed)
                Isolate.WhenCalled(() => fake.IntCall()).WillReturn(10);
            
                Assert.AreEqual(10, fake.IntCall());
            }
            </code>
            </example>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.IsolatedAttribute">
            <summary> Used to clean up the defined expectations. This attribute cant be inherited.</summary>
            <remarks>Any method marks with this attribute will clean all set expectation
            after the test is done. A marked class will do this for any test defined in
            it. The attribute can be replaced with the <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.CleanUp"/> method.</remarks>
            <example>
            <code lang="cs">
            [TestFixture]
            [Isolated]
            public TestClass
            {
                [Test]
                public void MyTest1()
                {
                    // the test code
                }
            }</code>
            
            <code lang="vbnet">
            &lt; TestFixture &gt;_
            &lt; Isolated &gt;_ 
            Public class TestClass
                &lt; Test &gt;_
                Public Sub MyTest1()
                   ' the test code
                End Sub
            End Class
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.IsolatedAttribute.#ctor">
            <summary>
            IsolatedAttribute constructor. Defines the DesignMode property
            to be the default Pragmatic mode.
            </summary>
            <seealso cref="T:TypeMock.ArrangeActAssert.IsolatedAttribute"/>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.IsolatedAttribute.#ctor(TypeMock.ArrangeActAssert.DesignMode)">
            <summary>
            IsolatedAttribute constructor. Let's you specify the DesignMode 
            to override the default Pragmatic mode for either the assmebly,
            class or test scope.
            </summary>
            <param name="design">Can be either of the following:
            <list type="bullet">
            <item>
            <description>Pragmatic. The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </description>
            </item>
            <item>
            <description>InterfaceOnly. This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a DesignModeException.
            </description>
            </item>
            </list>
            </param>
        </member>
        <member name="P:TypeMock.ArrangeActAssert.IsolatedAttribute.Design">
            <summary>
            This property defines the design mode for either an assembly, class or a test method scope.
            </summary>
            <value>
            By default, Isolator’s design mode is Pragmatic. In Pragmatic design mode, you can fake any 
            method in any class, including static, sealed or private. In InterfaceOnly design mode, only 
            virtual methods can be faked. Use the DesignMode property explicitly on either assembly, class 
            or a test to override the default, or a higher level specification. For example, you can 
            specify DesignMode.InterfaceOnly in the assembly level, but specify 
            DesignMode.Pragmatic for a specific test.
            
            The property can be set to one of the following values:
            <list type="bullet">
            <item>
            <description>
            Pragmatic. The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </description>
            </item>
            <item>
            <description>
            InterfaceOnly. This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a Typemock.DesignModeException.
            </description>
            </item>
            </list>
            </value>
            <example>
            <code lang="cs">
            [TestFixture]
            [Isolated(Design = DesignMode.InterfaceOnly)]
            public TestClass
            {
                [Test]
                public void MyTest1()
                {
                    // the test code
                }
            }</code>
            
            <code lang="vbnet">
            &lt; TestFixture &gt;_
            &lt; Isolated (Design := DesignMode.InterfaceOnly) &gt;_ 
            Public class TestClass
                &lt; Test &gt;_
                Public Sub MyTest1()
                   ' the test code
                End Sub
            End Class
            </code>
            </example>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.IsolatedAttribute.Execute">
            <summary>
            Called by the framework instead of the original method. This will run the original method and 
            afterwards clear the MockManager.
            </summary>
            <returns> the result of the original method</returns>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.DesignMode">
            <summary>
            The two different design modes available for mocking:
            <list type="bullet">
            <item>
            <description>
            Pragmatic. The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </description>
            </item>
            <item>
            <description>
            InterfaceOnly. This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a Typemock.DesignModeException.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.DesignMode.Pragmatic">
            <summary>
            The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </summary>
        </member>
        <member name="F:TypeMock.ArrangeActAssert.DesignMode.InterfaceOnly">
            <summary>
            This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a Typemock.DesignModeException.
            </summary>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Verifier.GetTimesCalled``1(System.Func{``0})">
            <summary>
            Return the calls count on non void method.
            </summary>        
            <param name="expression">A Func expression of the method we want to get the count.</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.ArrangeActAssert.Verifier.GetTimesCalled(System.Action)">
            <summary>
            Return the calls count on void method.
            </summary>        
            <param name="expression">An Action expression of the method we want to get the count.</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="T:TypeMock.RunnerUtils">
            <summary>
            Utilities Methods to use with Typemock Smart Runner
            </summary>
        </member>
        <member name="M:TypeMock.RunnerUtils.GetOriginalPath(System.Reflection.Assembly)">
            <summary>
            Find Original Path of Assembly while in test.
            </summary>
            <remarks>
            Typemock Smart Runner, copies all assemblies to a shadow copy in order to allow developers to continue to build while the tests are run.
            This is a helper method to reach original location
            </remarks>
            <example> 
            [Test]
            public void Test_That_Calls_A_File()
            {
               var fileLocation = RunnerUtils.GetOriginalPath(typeof(UnderTest).Assembly);
               var file = Path.Combine(Path.GetDirectoryName(fileLocation), "mydatabase.db");
               
               var result = UnderTest.ReadAllUsersIn(file);
               // Assert
            }    
            </example>
            <param name="assembly">An Assembly that is part of the test</param>
            <returns>path to original location</returns>
        </member>
        <member name="T:TypeMock.DontRunAttribute">
            <summary>
            TypemockRunnerAttribute signals Isolator automatic runner not to run the decorated method or class automatically
            </summary>
            <example>
            Usage example to signal runner to not run the test automatically
            <code> [TestMethod]
            [DontRun]
            public void SpecialTest()
            {
                // Test logic here
            }</code>
            </example>
            <remarks>
            If the test assembly doesn't have a reference to Isolator, it can be added a new attirbute with the same name
            and the runner will treat it the same way as it was decorated with Typemock DontRun attirubte.
            </remarks>
            <example>
            An example of custom attribute defined in test assembly
            <code> [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
            public class DontRunAttribute : Attribute { }
            </code>
            </example>
        </member>
    </members>
</doc>
